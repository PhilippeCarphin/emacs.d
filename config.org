#+OPTIONS: toc:1
#+REVEAL_MIN_SCALE: 0.1
#+REVEAL_HLEVEL: 4
#+PROPERTY: header-args :tangle yes :results none
#+COLUMNS: %25ITEM %header-args[(Header Args)][{Arguments controlling the evaluation of source blocks}]

* Basic
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:
** Minimalistic config
*** Intro
    #+REVEAL: split
 An elementary that can be taken as is to start from oriented towards leveragin
 the full power of orgmode immediately.
 - Sane miscellaneous defaults
 - A built in color theme that looks good in orgmode exports
 - Evil mode if you know vim but not emacs
 - Basic helper frameworks that are defacto standard
 - Elementary org configuration allowing immediate use of built in package babel.

**** This config file
   
 Emacs loads one file at startup from =~/.emacs=, =~/.emacs.d/init.el=.  The s
*** Package stuff

    Standard stuff that is at the start of everyone's config file.
 #+begin_src emacs-lisp
 (require 'package)
 (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
 (add-to-list 'package-archives '("org"   . "http://orgmode.org/elpa/") t)
 (add-to-list 'package-archives '("gnu"   . "http://elpa.gnu.org/packages/") t)
 (package-initialize)
 #+end_src

 Standard way for installing packages.  This replaces the use of =(require
 a-package)= and adds convenience functions.

 #+begin_src emacs-lisp
 (unless (package-installed-p 'use-package)
     (package-refresh-contents)
     (package-install 'use-package))
 (eval-when-compile (require 'use-package))
 #+end_src

*** Scrolling behavior

 - =scroll-margin= Distance between cursor and top/bottom before scrolling starts.
 - =scroll-step= makes the window move one line at a time.

 #+BEGIN_SRC emacs-lisp
 (setq scroll-step 1)
 (setq-default scroll-margin 10)
 #+end_src

*** Cursor style
   
 This will make our cursor a vertical bar instead of a box.

 If evil mode is active, this will cause our insert-mode cursor to be a bar and
 our normal mode cursor to be a box.

 #+begin_src emacs-lisp
 (setq-default cursor-type '(bar . 3))
 (set-cursor-color "light grey")
 (custom-set-faces '(cursor ((t (:background "SlateGray3")))))
 #+end_src

 I use vi whenever I want to open files in a shell.  Because I use vi, when I see
 the box cursor, I feel like I'm in VI, but when I press keys, it just writes
 text.  So I press ESC, doesn't do anything, ESC again : "ESC ESC is not bound to
 anything".

*** Cursor blink
    :PROPERTIES:
    :HEADER-ARGS: :tangle no
    :END:

 #+begin_src emacs-lisp
 (blink-cursor-mode)
 #+end_src

*** Wrapping

 Automattically hard-wrap text on 80 chars.

 #+begin_src emacs-lisp
 (setq-default auto-fill-function 'do-auto-fill)
 (setq-default fill-column 80)
 #+end_src

*** Startup color theme

 Dark theme that exports well

 #+begin_src emacs-lisp
 (load-theme 'misterioso)
 #+end_src

 #+RESULTS:
 : t

***** Explanation                                           :noexport_reveal:

     The default emacs theme looks good when exporting to HTML.  But because of
     =htmlize=, with dark themes, the code can come out looking bad in exports
     when text colors meant for dark backgrounds appear over the light background
     of the HTML.

     One of the built-in color themes where code looks good on light backgrounds
     and which is easy on the eyes is =misterioso=

     Although the default emacs theme exports well, it's not easy on the eyes in
     emacs itself.  A light theme that exports well and looks good in emacs is
     =leuven=.
    
*** Startup font
   
 To change the font, as per this [[http://emacs.1067599.n8.nabble.com/Changing-font-size-of-all-the-buffers-including-the-status-line-and-the-characters-shown-in-electricr-tp466906p466932.html][Mailing list post]].

 #+begin_src emacs-lisp
 (custom-set-faces '(default ((t (:height 200)))))
 #+end_src

*** Helper frameworks

**** Undo tree
     Use =C-x u= to get an undo tree buffer, really strong!
 #+begin_src emacs-lisp
 (use-package undo-tree
   :ensure t
   :config (global-undo-tree-mode))
 #+end_src
**** Helm
      :PROPERTIES:
      :HEADER-ARGS: :tangle yes
      :END:

 Improve searching interface all over emacs.

 Calling =helm-mode= remaps lots of emacs functions to their =helm=-ized
 equivalents.

 We also add a few ourselves.

 #+begin_src emacs-lisp :results none
 (use-package helm :ensure t
   :config
     (require 'helm-config)
   :bind (("M-x" . helm-M-x)
	  ("C-x C-f" . helm-find-files)
	  ("C-x C-r" . helm-recentf)
	  ("C-h C-i" . helm-info)
	  ("C-x C-b" . helm-buffers-list)
	  ("C-c g" . helm-grep-do-git-grep)))
 #+end_src

 #+begin_src emacs-lisp
 (helm-mode)
 #+end_src
***** Remapped functions

      Notable remapped functions:
 - =M-x= adds helm when writing function
 - Files and buffers
   - =helm-recentf=
   - =helm-find-files=
   - =helm-buffer-list=
 - =helm-mode=
   - =describe-function=
   - =describe-symbol=

***** Powerful tools

 - =helm-grep-do-git-grep=

**** Which-key

 Help discovering available key sequences in all contexts.

 Originally developped for spacemacs, now part of the standard emacs packages.

 #+begin_src emacs-lisp
 (use-package which-key
   :ensure t
   :delight
   :init
   (setq which-key-separator " ")
   (setq which-key-prefix-prefix "+")
   (setq which-key-idle-delay 0.01)
   :config
   (which-key-mode))
 #+end_src

**** Standard autocomplete
     :PROPERTIES:
     :HEADER-ARGS: :tangle yes
     :END:

 #+begin_src emacs-lisp
 (use-package company
   :ensure t
   :config (global-company-mode)
           (setq company-idle-delay 0))
 #+end_src
*** Evil mode
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
   
 Evil-mode is a by far the best VI emulation out there.  It is very exact.

 The only thing that is very different is that not all buffers are going to be in
 evil mode.

 At the start, this the most confusing thing in the world.  Once you get used to
 it it's not a big deal.  After a while, you still make mistakes in that sense
 but if you thought you were in evil mode and you pressed the wrong key, you know
 how to fix it.  It becomes like pressing backspace when you make a typo,
 something barely noticed.

**** Install and activate

 #+begin_src emacs-lisp :results none
   (use-package evil
     :ensure t
     :init (setq evil-want-C-i-jump nil)
	   (setq evil-want-integration t)
	   (setq evil-want-C-u-scroll t)
     :config (evil-mode 1)
             (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
             (evil-global-set-key 'motion "j" 'evil-next-visual-line)
             (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
             (setq evil-default-state 'emacs)
             (setq evil-insert-state-modes nil)
             (setq evil-motion-state-modes nil)
             (setq evil-normal-state-modes '(fundamental-mode
                                             conf-mode
                                             prog-mode
                                             text-mode
                                             dired))
	     (setq evil-insert-state-cursor '((bar . 2) "lime green")
		 evil-normal-state-cursor '(box "yellow"))
             (add-hook 'with-editor-mode-hook 'evil-insert-state))
 #+end_src

 The =evil-want-C-i-jump= is very important.  When running emacs in the shell,
 the TAB key doesn't work properly.

 Reference : [[https://www.youtube.com/watch?v=xaZMwNELaJY][Emacs From Scratch #3 : Keybindings and Evil]] et la config de Sam.

***** TODO Look into rune/evil-hook

**** Vim like window split keys

 #+begin_src emacs-lisp
 (define-key evil-insert-state-map (kbd "C-w") evil-window-map)
 (define-key evil-insert-state-map (kbd "C-w /") 'split-window-right)
 (define-key evil-insert-state-map (kbd "C-w -") 'split-window-below)
 #+END_SRC

**** Map undo keys to undo-tree function

 #+begin_src emacs-lisp
 (define-key evil-normal-state-map (kbd "C-r") 'undo-tree-redo)
 (define-key evil-normal-state-map (kbd "u") 'undo-tree-undo)
 #+end_src

*** Help   
**** Helper keymap
   
  A keymap of keys to know to get started.  You should get rid of this of this
  section once you are familiar with the keys in order to learn the real bindings
  for the functions given by this keymap.
   
  #+begin_src emacs-lisp
  (defun about-this-keymap () (interactive)
    (org-open-link-from-string "[[file:~/.emacs.d/config.org::Helper keymap]]"))
  #+end_src
  
   Also, how meta is it that we have a function whose implementation takes us to
   see its implementation!

  #+begin_src emacs-lisp
    (define-prefix-command 'emacs-movement)
    (global-set-key (kbd "C-| m") 'emacs-movement)
    (global-set-key (kbd "C-| h") 'about-this-keymap)
    (define-key emacs-movement (kbd "C-f") 'forward-char)
    (define-key emacs-movement (kbd "C-b") 'backward-char)
    (define-key emacs-movement (kbd "C-p") 'previous-line)
    (define-key emacs-movement (kbd "C-v") 'scroll-up-command)
    (define-key emacs-movement (kbd "M-v") 'scroll-down-command)
    (define-key emacs-movement (kbd "C-s") 'isearch-forward)
    (define-key emacs-movement (kbd "C-r") 'isearch-backward)
    (define-prefix-command 'C-x)
    (global-set-key (kbd "C-| C-x") 'C-x)
    (define-key C-x (kbd "C-f") 'helm-find-files)
    (define-key C-x (kbd "C-r") 'helm-recentf)
    (define-key C-x (kbd "C-b") 'helm-buffers-list)
    (define-key C-x (kbd "b") 'switch-to-buffer)
    (define-key C-x (kbd "C-s") 'save-buffer)
    (define-key C-x (kbd "C-c") 'save-buffers-kill-emacs)
    (define-key emacs-movement (kbd "C-n") 'next-line)
    (define-prefix-command 'C-h)
    (global-set-key (kbd "C-| C-h") 'C-h)
    (define-key C-h (kbd "C-i") 'helm-info)
    (define-key C-h (kbd "o") 'describe-symbol)
    (define-key C-h (kbd "f") 'describe-function)
    (define-key C-h (kbd "k") 'describe-key)
    (define-prefix-command 'orgmode)
    (global-set-key (kbd "C-| o") 'orgmode)
    (define-key orgmode (kbd "C-c C-,") 'org-insert-structure-template)
    (define-key orgmode (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
    (define-key orgmode (kbd "C-c '") 'org-edit-special)
    (define-key orgmode (kbd "C-c .") 'org-time-stamp)
    (define-key orgmode (kbd "C-c C-s") 'org-schedule)
    (define-key orgmode (kbd "C-c C-d") 'org-deadline)
    (define-key orgmode (kbd "a") 'org-agenda)
    (define-key orgmode (kbd "v") 'org-tags-view)
    (define-key orgmode (kbd "C-c /") 'org-match-sparse-tree)
    (define-key orgmode (kbd "<M-S-left>") 'org-promote-subtree)
    (define-key orgmode (kbd "<M-S-right>") 'org-demote-subtree)
    (define-key orgmode (kbd "n") 'org-narrow-to-subtree)
    (define-key orgmode (kbd "c") 'org-columns)
  #+end_src

***** Explanations

  La touche =C-|= (=C-S-\=) est une map de touches qui contient des
  fonctionnalité spécialement sélectionnées.

  Le choix de touche de départ est de choisr un binding qui fait chier à faire.

  Le but c'est d'explorer.  Quand on trouve quelque chose qu'on aime, on peut
  découvrir les bindings standards en faisant =C-h f= et écrire le nom de la
  fonction exécutée par la touche.  Ou faire =C-h k= et refaire la touche et
  l'aide nous dira quels sont les autres bindings pour la fonctionnalité.

  Si un binding a le même nom que la fonction comme =C-h=, c'est que ce groupe est
  une sélection des fonctions disponibles en faisant =C-h= normalement.

  Si le groupe contient le mot mode, c'est qu'il contient des fonctions qui sont
  seulement disponibles dans un certain mode.

  Les touches utilisées sont le plus souvent possible la même touche qu'on ferait
  normalement. Par exemple, =C-| o C-c C-,= insère un bloc de code source.  Le
  choix est fait comme ça parce que la touche =C-c C-,= est la touche native pour
  faire cette action.


**** Help menu
       #+begin_src emacs-lisp
      (defun org-agenda-help () (interactive)
	 (org-open-link-from-string "[[file:~/.emacs.d/config.org::*Orgmode implementation of GTD]]"))
      (define-prefix-command 'help-menu)
      (global-set-key (kbd "C-~") 'help-menu)
      (define-key 'help-menu (kbd "a") 'org-agenda-help)
       (easy-menu-define h-menu global-map
	 "Menu for word navigation commands."
	 '("PhilHelp"
	   ["forward-char" forward-char]
	   ["backward-char" forward-char]
	   ["next-line" next-line]
	   ["previous-line" previous-line]
	   ["describe-key" describe-key]
	   ["scroll-up-command" scroll-up-command]
	   ["scroll-down-command" scroll-down-command]
           ["isearch-forward" isearch-forward]
           ["isearch-backward" isearch-backward]
	   ["org-time-stamp" org-time-stamp]
	   ["org-promote-subtree" org-promote-subtree]
	   ["org-demote-subtree" org-demote-subtree]
	   ["org-agenda-help" org-agenda-help]))
       #+end_src

    (global-set-key (kbd "C-| m") 'emacs-movement)
    (global-set-key (kbd "C-| h") 'about-this-keymap)
    (define-key emacs-movement (kbd "C-f") 'forward-char)
    (define-key emacs-movement (kbd "C-b") 'backward-char)
    (define-key emacs-movement (kbd "C-p") 'previous-line)
   
** Basic org configuration
*** Bullets
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:

 Show nice bullets

 Essential for easy tree viewing

 #+begin_src emacs-lisp
 (use-package org-bullets
   :ensure t
   :hook (org-mode . org-bullets-mode))
 #+end_src

*** Exporting

 - =ox-twbs= to export to beautiful HTML
 - =ox-reveal= to export to Reveal.js presentation
 - =ox-rst= to generate Restructured Text for sphinx documentation
 - =ox-gfm= to generate github flavored markdown
 - =htmlize= for colored code in all export formats

 #+begin_src emacs-lisp
 (use-package ox-gfm :ensure t)
 (use-package ox-rst :ensure t)
 (use-package ox-twbs :ensure t)
 (use-package ox-reveal :ensure t
   :config (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
 ;; (use-package htmlize :ensure t)
 #+end_src

*** Babel
**** Babel Intro
 Babel allows running of code blocks.  It is what enables this config to be in
 orgmode format.

 The ability to evaluate code in orgmode source blocks is built in with emacs but
 must be activated to be used:

 https://orgmode.org/worg/org-contrib/babel/languages/index.html#configure

**** Babel config
 We simply add languages that we want to become available.  There are many more
 but some of them require installing extra packages.

 #+begin_src emacs-lisp
 (org-babel-do-load-languages 'org-babel-load-languages
     '((shell . t)
       (python . t)))
 #+end_src

**** Disable prompt
 As a security precaution this is off by default.  It would indeed be quite
 surprising if your text editor runs a shell command if you accidently do =C-c
 C-c=.

 But if you know it exists, then there is no big deal.  Indeed one is not
 surprised that a command runs when the press enter in a shell.

 #+begin_src emacs-lisp
 (setq org-confirm-babel-evaluate nil)
 #+end_src
    
*** Present GUI menu

   This adds the "Present" menu at the top with menu item "Present Now".

   #+begin_src emacs-lisp :results none
     (defun ox-reveal () (interactive) (org-reveal-export-to-html-and-browse nil t))
     (defun ox-twbs () (interactive) (browse-url (org-twbs-export-to-html nil t)))
     (defun ox-twbs-all () (interactive) (browse-url (org-twbs-export-to-html nil nil)))
     (defun ox-html () (interactive) (browse-url (org-html-export-to-html nil t)))
     (defun ox-html-all () (interactive) (browse-url (org-html-export-to-html nil nil)))
     (defun ox-rst () (interactive) (org-open-file (org-rst-export-to-rst nil t)))
     (defun ox-rst-all () (interactive) (org-open-file (org-rst-export-to-rst nil nil)))
     (easy-menu-define present-menu org-mode-map
       "Menu for word navigation commands."
       '("Present"
	 ["Present Right Now (C-c C-e R B)" org-reveal-export-to-html-and-browse]
	 ["Present Subtree Right Now (C-c C-e C-s R B)" ox-reveal]
	 ["View Twitter Bootstrap HTML Right now (C-c C-e C-s w o)" ox-twbs]
	 ["View Twitter Bootstrap HTML all Right now (C-c C-e w o)" ox-twbs-all]
	 ["View RST Right Now (C-c C-e C-s r R)" ox-rst]
	 ["View RST All Right Now (C-c C-e r R)" ox-rst-all]
	 ["View straight-pipe HTML Right Now (C-c C-e C-s h o)" ox-html]
	 ["View straight-pipe HTML All Right Now (C-c C-e h o)" ox-html-all]))
   #+end_src

** Basic org agenda configuration
*** Agena files
 https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
 #+begin_src emacs-lisp
 (setq org-agenda-dir "~/Documents/gtd")
 (setq org-agenda-files (list org-agenda-dir))
 #+end_src
*** Agenda Key
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
 I mapped a key because I like to pop in and out of it. I don't use it myself
 because the I put =org-agenda= on a keymap for my GTD stuff.

 #+begin_src emacs-lisp
 (global-set-key (kbd "C-c a") 'org-agenda)
 #+end_src

   #+REVEAL: split
    
*** Refile targets
 #+begin_src emacs-lisp
 (setq org-refile-targets '((nil :maxlevel . 2) (org-agenda-files :maxlevel . 3)))
 (setq org-outline-path-complete-in-steps nil)
 (setq org-refile-use-outline-path 'file)
 #+end_src
*** Capture templates
 #+begin_src emacs-lisp
 (setq org-capture-templates 
   '(("i" "GTD Input" entry (file+headline gtd-in-tray-file "GTD Input Tray")
      "* GTD-IN %?\n %i\n %a" :kill-buffer t)))
 #+end_src
*** Capture hotkey
 #+begin_src emacs-lisp
 (defun org-capture-input () (interactive) (org-capture nil "i"))
 (global-set-key (kbd "C-c c") 'org-capture-input)
 #+end_src


* Phil
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:
** GTD
*** Keymap for GTD keybindings
      We define a keymap that will be accessed with =SPC a g=
 #+begin_src emacs-lisp
   (define-prefix-command 'gtd)
 #+end_src

   #+begin_src emacs-lisp
   ;; (global-set-key (kbd "C-c a g") 'gtd)
   (define-key gtd (kbd "a") 'org-agenda)
   (define-key gtd (kbd "c") 'org-capture)
   #+end_src

 #+RESULTS:
 : org-capture


   #+REVEAL: split

*** GTD files
**** Filename symbols
 #+begin_src emacs-lisp :results none
 (setq org-agenda-dir "~/NDocuments/gtd/")
 (setq org-agenda-files '("~/NDocuments/gtd"))
 (setq gtd-in-tray-file (concat org-agenda-dir "GTD_InTray.org")
     gtd-next-actions-file (concat org-agenda-dir "GTD_NextActions.org")
     gtd-project-list-file (concat org-agenda-dir "GTD_ProjectList.org")
     gtd-reference-file (concat org-agenda-dir "GTD_Reference.org")
     gtd-someday-maybe-file (concat org-agenda-dir "GTD_SomedayMaybe.org")
     gtd-tickler-file (concat org-agenda-dir "GTD_Tickler.org")
     gtd-journal-file (concat org-agenda-dir "GTD_Journal.org"))
 #+end_src
**** Quick access to GTD files

 We use it to create bindings in the =gtd= map to open files

 #+begin_src emacs-lisp
   (defun gtd-open-in-tray      () (interactive) (find-file gtd-in-tray-file))
   (defun gtd-open-project-list () (interactive) (find-file gtd-project-list-file))
   (defun gtd-open-reference   () (interactive) (find-file gtd-reference-file))
   (defun gtd-open-next-actions () (interactive) (find-file gtd-next-actions-file))
   (define-key gtd (kbd "i") 'gtd-open-in-tray)
   (define-key gtd (kbd "p") 'gtd-open-project-list)
   (define-key gtd (kbd "r") 'gtd-open-reference)
   (define-key gtd (kbd "n") 'gtd-open-next-actions)
 #+end_src

   #+REVEAL: split
*** Todo keywords for GTD

 The first set of keywords is a generic set of keywords that I can give TODO
 keywords to items without having them be part of my GTD.

 The GTD-* keywords map to the various things that what David Allen calls "stuff"
 can be.

 #+begin_src emacs-lisp
 (setq org-todo-keywords '((sequence "TODO" "WAITING" "VERIFY" "|" "DONE")
			   (sequence 
                              "GTD-IN(i)"
                              "GTD-CLARIFY(c)"
			      "GTD-PROJECT(p)"
                              "GTD-SOMEDAY-MAYBE(s)"
			      "GTD-ACTION(a)"
                              "GTD-NEXT-ACTION(n)"
                              "GTD-WAITING(w)"
			      "|"
                              "GTD-REFERENCE(r)"
                              "GTD-DELEGATED(g)"
			      "GTD-DONE(d)")))
			   
 (setq org-todo-keyword-faces
    '(("GTD-IN" :foreground "#ff8800" :weight normal :underline t :size small)
      ("GTD-PROJECT" :foreground "#0088ff" :weight bold :underline t)
      ("GTD-ACTION" :foreground "#0088ff" :weight normal :underline nil)
      ("GTD-NEXT-ACTION" :foreground "#0088ff" :weight bold :underline nil)
      ("GTD-WAITING" :foreground "#aaaa00" :weight normal :underline nil)
      ("GTD-REFERENCE" :foreground "#00ff00" :weight normal :underline nil)
      ("GTD-SOMEDAY-MAYBE" :foreground "#7c7c74" :weight normal :underline nil)
      ("GTD-DONE" :foreground "#00ff00" :weight normal :underline nil)))
 #+end_src

   #+REVEAL: split
*** Definition of stuck projects

 In GTD projects are called "stuck" if they do not contain a =GTD-NEXT-ACTION=.
 This says that a stuck project is a headline where the todo keyword is
 =GTD-PROJECT= that do not contain a heading matching =GTD-NEXT-ACTION=.

 #+begin_src emacs-lisp
 (setq org-stuck-projects
       '("TODO=\"GTD-PROJECT\"" ;; Search query
         ("GTD-NEXT-ACTION")    ;; Not stuck if contains
         ()                     ;; Stuck if contains
         ""))                   ;; General regex
 #+end_src

*** Date interval for agenda view

 The default is kind of annoying.  It shows a week starting on a Sunday but what
 is annoying about that is that on Sunday, the agenda won't show what you have
 tomorrow!

 The way this is set, it will show 10 days starting 3 days in the past.

 #+begin_src emacs-lisp :results none
 (setq org-agenda-span 7
       org-agenda-start-on-weekday 0
       org-agenda-start-day "-2d")
 #+end_src

   #+REVEAL: split
    
*** Agenda custom commands
**** Definition
  #+begin_src emacs-lisp
  (setq org-agenda-custom-commands
	'(("c" "Simple agenda view"
            ((tags "PRIORITY=\"A\"")
             (stuck "" )
             (agenda "")
             (todo "GTD-ACTION")))
          ("g" . "GTD keyword searches searches")
          ("gi" todo "GTD-IN")
          ("gc" todo "GTD-CLARIFY")
          ("ga" todo "GTD-ACTION")
          ("gn" todo-tree "GTD-NEXT-ACTION")
          ("gp" todo "GTD-PROJECT")))
  #+end_src

 Run the agenda with "c" custom command.

**** Hotkeys in agenda binding
 #+begin_src emacs-lisp
 (defun gtd-agenda-view () (interactive) (org-agenda nil "c"))
 (defun gtd-next-action-sparse-tree () (interactive) (find-file
 gtd-project-list-file) (org-agenda nil "gn"))
 (global-set-key (kbd "C-c a") 'gtd-agenda-view)
 (global-set-key (kbd "C-c n") 'gtd-next-action-sparse-tree)
 #+end_src

*** Closing notes
 #+begin_src emacs-lisp :results none
 (setq org-log-done 'note)
 #+end_src
*** Evil mode agenda binding (SPC a g)
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
     Only use this if evil mode is activated

     I should put it in the evil mode config but I don't want it to depend on other things
    #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "SPC a g") 'gtd)
    #+end_src

** Advanced
*** Magit

 The most amazing vim plugin in existence.

 #+begin_src emacs-lisp
 (use-package magit
   :ensure t
   :custom
   (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
 #+end_src


 Error (use-package): ox-twbs/:catch: Symbol’s function definition is void: org-element-update-syntaxError (use-package): ox-twbs/:catch: Symbol’s function definition is void: org-element-update-syntaxError (use-package): ox-twbs/:catch: Symbol’s function definition is void: org-element-update-syntax* New

*** Yasnippet
 Note: package =yasnippet= doesn't come with the library of snippets but
 =yasnippet-snippets= comes with them and has =yasnippet= as a dependency
 therefore we only need to install this one.
 #+begin_src emacs-lisp :results none
 (use-package yasnippet-snippets
   :ensure t
   :config (yas-global-mode 1))
 #+end_src

*** RSS

 From [[https://gerlacdt.github.io/posts/emacs-elfeed/][Emacs as an RSS reader]]

 #+begin_src emacs-lisp :results none
 ;; data is stored in ~/.elfeed 
 (use-package elfeed :ensure t)
 (setq elfeed-feeds
       '(
         ;; programming
         ("https://news.ycombinator.com/rss" hacker)
         ("https://www.heise.de/developer/rss/news-atom.xml" heise)
         ("https://www.reddit.com/r/programming.rss" programming)
         ("https://www.reddit.com/r/emacs.rss" emacs)

         ;; programming languages
         ("https://www.reddit.com/r/golang.rss" golang)
         ("https://www.reddit.com/r/java.rss" java)
         ("https://www.reddit.com/r/javascript.rss" javascript)
         ("https://www.reddit.com/r/typescript.rss" typescript)
         ("https://www.reddit.com/r/clojure.rss" clojure)
         ("https://www.reddit.com/r/python.rss" python)

         ;; cloud
         ("https://www.reddit.com/r/aws.rss" aws)
         ("https://www.reddit.com/r/googlecloud.rss" googlecloud)
         ("https://www.reddit.com/r/azure.rss" azure)
         ("https://www.reddit.com/r/devops.rss" devops)
         ("https://www.reddit.com/r/kubernetes.rss" kubernetes)
 ))

 (setq-default elfeed-search-filter "@2-days-ago +unread")
 (setq-default elfeed-search-title-max-width 100)
 (setq-default elfeed-search-title-min-width 100)
 #+end_src

*** Remap C-x C-c for deamon usage
    I use :q to quit
 #+begin_src emacs-lisp
 (global-set-key (kbd "C-x C-c") 'save-buffers-kill-emacs)
 #+end_src

** Inactive stuff

*** Dynamic cursor
    :PROPERTIES:
    :header-args: :tangle no
    :END:
 Emacs crashed while I had this going.  I don't know if it is related.
 #+begin_src emacs-lisp
 (setq djcb-read-only-color       "gray")
 ;; valid values are t, nil, box, hollow, bar, (bar . WIDTH), hbar,
 ;; (hbar. HEIGHT); see the docs for set-cursor-type

 (setq djcb-read-only-cursor-type 'hbar)
 (setq djcb-overwrite-color       "red")
 (setq djcb-overwrite-cursor-type 'box)
 (setq djcb-normal-color          "yellow")
 (setq djcb-normal-cursor-type    'bar)

 (defun djcb-set-cursor-according-to-mode ()
   "change cursor color and type according to some minor modes."

   (cond
     (buffer-read-only
       (set-cursor-color djcb-read-only-color)
       (setq cursor-type djcb-read-only-cursor-type))
     (overwrite-mode
       (set-cursor-color djcb-overwrite-color)
       (setq cursor-type djcb-overwrite-cursor-type))
     (t 
       (set-cursor-color djcb-normal-color)
       (setq cursor-type djcb-normal-cursor-type))))

 (add-hook 'post-command-hook 'djcb-set-cursor-according-to-mode)
 #+end_src

*** Evil terminal curson
    :PROPERTIES:
    :HEADER-ARGS: :tangle no
    :END:

 #+begin_src emacs-lisp
 (unless (display-graphic-p)
           (require 'evil-terminal-cursor-changer)
           (evil-terminal-cursor-changer-activate) ; or (etcc-on)
           )
 #+end_src
  

