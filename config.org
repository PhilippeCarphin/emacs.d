-*- coding: utf-8 -*-
#+TITLE: Emacs config file
#+OPTIONS: toc:1
#+REVEAL_MIN_SCALE: 0.1
#+REVEAL_HLEVEL: 4
#+PROPERTY: header-args :tangle yes :results none
#+COLUMNS: %40ITEM %header-args[(Header Args)][{Arguments controlling the evaluation of source blocks}] %TAGS
#+OPTIONS: broken-links:mark

#+ATTR_ORG: :width 100px
[[file:unicorn.jpg]]

Keys sparse tree : Evaluate (org-tags-sparse-tree nil "command|keys") with
=C-x C-e=.  Pressing =C-c C-c= will get out of the sparse tree view
created by the expression.


* Bootstrap & =use-package=
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
   Standard stuff that is at the start of everyone's config file.
** Standard package repositories
#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org"   . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("gnu"   . "http://elpa.gnu.org/packages/") t)
(package-initialize)
#+end_src

** =use-package= macro
Standard way for installing packages.  This replaces the use of =(require
a-package)= and adds convenience functions.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
(eval-when-compile (require 'use-package))
#+end_src
** Define leader keymap
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:
In this config file, we will "add" keys to this map.

We therefore want it to exist from the very start
#+begin_src emacs-lisp :results output
(define-prefix-command 'leader-key)
#+end_src
This will be bound to =M-m= and in evil-normal-state-map to =SPC=.

* Emacs
** Small basic configs
*** Indent with tabs
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:
#+begin_src emacs-lisp
(custom-set-variables '(indent-tabs-mode nil))
#+end_src
*** Get rid of toolbar
:PROPERTIES:
:header-args: :tangle yes
:END:
#+begin_src emacs-lisp
(tool-bar-mode -1)
#+end_src
*** Get rid of scroll bars
:PROPERTIES:
:header-args: :tangle no
:END:
#+begin_src emacs-lisp
(scroll-bar-mode -1)
#+end_src
*** Scrolling behavior
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

- =scroll-margin= Distance between cursor and top/bottom before scrolling starts.
- =scroll-step= makes the window move one line at a time.

#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq-default scroll-margin 10)
#+end_src

*** Higlight current line
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
Highlight the current line.  This looks really good with the theme =leuven= but
it is kind of annoying in =misterioso=.
#+begin_src emacs-lisp
(global-hl-line-mode 1)
#+end_src

*** Cursor style
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Makes the cursor a bar instead of a box.

#+begin_src emacs-lisp
(setq-default cursor-type '(bar . 3))
(set-cursor-color "light grey")
(custom-set-faces '(cursor ((t (:background "SlateGray3")))))
#+end_src

Helps to not get confused with vim.

*** Cursor blink
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(blink-cursor-mode)
#+end_src

*** Wrapping
**** Hard wrap as you type
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
Automattically hard-wrap text on 80 chars as you type.

#+begin_src emacs-lisp
(setq-default auto-fill-function 'do-auto-fill)
(setq-default fill-column 80)
#+end_src

**** Wrap lines visually
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
Wrap lines visually (lines that are too long are /displayed/ on multiple lines
with a special char indicating visual wrapping.

#+begin_src emacs-lisp
(global-visual-line-mode 1)
#+end_src

*** Startup color theme
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Dark theme that exports well

#+begin_src emacs-lisp
(load-theme 'misterioso)
#+end_src

***** Explanation                                       :noexport_reveal:

    The default emacs theme looks good when exporting to HTML.  But because of
    =htmlize=, with dark themes, the code can come out looking bad in exports
    when text colors meant for dark backgrounds appear over the light background
    of the HTML.

    One of the built-in color themes where code looks good on light backgrounds
    and which is easy on the eyes is =misterioso=

    Although the default emacs theme exports well, it's not easy on the eyes in
    emacs itself.  A light theme that exports well and looks good in emacs is
    =leuven=.

*** Startup font
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

To change the font, as per this [[http://emacs.1067599.n8.nabble.com/Changing-font-size-of-all-the-buffers-including-the-status-line-and-the-characters-shown-in-electricr-tp466906p466932.html][Mailing list post]].

#+begin_src emacs-lisp
(custom-set-faces '(default ((t (:height 150)))))
#+end_src

*** Follow symlinks
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(custom-set-variables '(vc-follow-symlinks nil))
#+end_src

*** Remap C-x C-c to save buffers before quitting
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
    I use :q to quit
 #+begin_src emacs-lisp
 (global-set-key (kbd "C-x C-c") 'save-buffers-kill-emacs)
 #+end_src
  
*** Visual line mode markers
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(custom-set-variables '(visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow)))
#+end_src
** Helper frameworks
*** Undo tree
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
    Use =C-x u= to get an undo tree buffer, really strong!
#+begin_src emacs-lisp
(use-package undo-tree
  :ensure t
  :config (global-undo-tree-mode))
#+end_src
*** Helm
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Improve searching interface all over emacs.

Calling =helm-mode= remaps lots of emacs functions to their =helm=-ized
equivalents.

We also add a few ourselves.

#+begin_src emacs-lisp :results none
(use-package helm :ensure t
  :config
    (require 'helm-config)
  :bind (("M-x" . helm-M-x)
	 ("C-x C-f" . helm-find-files)
	 ("C-x C-r" . helm-recentf)
	 ("C-h C-i" . helm-info)
	 ("C-x C-b" . helm-buffers-list)
	 ("C-c g" . helm-grep-do-git-grep)))
#+end_src

#+begin_src emacs-lisp
(helm-mode)
#+end_src
**** Remapped functions

     Notable remapped functions:
- =M-x= adds helm when writing function
- Files and buffers
  - =helm-recentf=
  - =helm-find-files=
  - =helm-buffer-list=
- =helm-mode=
  - =describe-function=
  - =describe-symbol=

**** Powerful tools

- =helm-grep-do-git-grep=

*** Which-key
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Help discovering available key sequences in all contexts.

Originally developped for spacemacs, now part of the standard emacs packages.

#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :delight
  :init
  (setq which-key-separator " ")
  (setq which-key-prefix-prefix "+")
  (setq which-key-idle-delay 0.01)
  :config
  (which-key-mode))
#+end_src

*** Standard autocomplete
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :config (global-company-mode)
	  (setq company-idle-delay 0))
#+end_src
    
** Evil mode
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:
*** Description
Evil-mode is a by far the best VI emulation out there.  It is very exact.

The only thing that is very different is that not all buffers are going to be in
evil mode.

At the start, this the most confusing thing in the world.  Once you get used to
it it's not a big deal.  After a while, you still make mistakes in that sense
but if you thought you were in evil mode and you pressed the wrong key, you know
how to fix it.  It becomes like pressing backspace when you make a typo,
something barely noticed.
*** Config
**** Package evil
#+begin_src emacs-lisp :results none
  (use-package evil
    :ensure t
    :init (setq evil-want-C-i-jump nil)
	  (setq evil-want-integration t)
	  (setq evil-want-C-u-scroll t)
    :config (evil-mode 1)
	  (define-key evil-normal-state-map (kbd "SPC") 'leader-key)
	    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
	    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
	    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
	    (define-key evil-insert-state-map (kbd "C-w") evil-window-map)
	    (define-key evil-insert-state-map (kbd "C-w /") 'split-window-right)
	    (define-key evil-insert-state-map (kbd "C-w -") 'split-window-below)
	    (define-key evil-normal-state-map (kbd "C-r") 'undo-tree-redo)
	    (define-key evil-normal-state-map (kbd "u") 'undo-tree-undo)
	    (global-set-key (kbd "M-u") 'universal-argument)
	    (setq evil-default-state 'emacs)
	    (setq evil-insert-state-modes nil)
	    (setq evil-motion-state-modes nil)
	    (setq evil-normal-state-modes '(fundamental-mode
					    conf-mode
					    prog-mode
					    text-mode
					    dired))
	    (setq evil-insert-state-cursor '((box . 2) "lime green")
		evil-normal-state-cursor '(box "yellow"))
            (setq evil-move-cursor-back nil)
	    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+end_src

The =evil-want-C-i-jump= is very important.  When running emacs in the shell,
the TAB key doesn't work properly.

Reference : [[https://www.youtube.com/watch?v=xaZMwNELaJY][Emacs From Scratch #3 : Keybindings and Evil]] et la config de Sam.

**** Package evil-escape
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(use-package evil-escape
  :ensure t
  :config
  (evil-escape-mode)
  (setq-default evil-escape-key-sequence "jk"))
#+end_src

#+RESULTS:
: t
*** Cursor blinking

 Le curseur flash tout le temps (le comporttement par défaut est de flashe 10
 fois avant d'arrêter).

 #+begin_src emacs-lisp
 (add-hook 'evil-insert-state-exit-hook (lambda () (blink-cursor-mode 0)))
 (add-hook 'evil-insert-state-entry-hook (lambda () (blink-cursor-mode 0)))
 #+end_src

 This sets the amount of cursor blinks before the flashing stop.

 #+begin_src
 (setq blink-cursor-blinks 0)
 #+end_src

 Make sure the cursor starts out not blinking

 #+begin_src emacs-lisp
 (blink-cursor-mode 0)
 #+end_src
 
 
* Helper functions
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(defun sci-open () (interactive)
(helm-find-files-1 "/plink:phc001@hpcr5-in:/fs/homeu2/eccc/cmd/cmds/phc001/"))
#+end_src


* Orgmode & Agenda
** Orgmode
*** Changer l'apparence de contenu caché
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

  #+begin_src emacs-lisp
(defun configure-ellipsis () (set-display-table-slot standard-display-table
  'selective-display (string-to-vector " ⤵")))

(add-hook 'org-mode-hook 'configure-ellipsis)
  #+end_src

From [[https://emacs.stackexchange.com/a/10988/19972][Référence]].  You can copy
paste any unicode character in here from a browser

Other options : ▼, ↴, ⬎, ⤵, ⤷, ↯, ⟾, ⋱, ….

*** Display links as normal text
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

If you use the hotkeys to work with links the default behavior is OK but if you
want to just manipulate the text, what orgmode does to hide links is really
annoying.

You have to delete a bracket to get the real text to show up.
[[https://google.com][Google]]

#+begin_src emacs-lisp
(setq org-descriptive-links nil)
;; Note (org-mode-restart) is required for this to take effect
#+end_src

**** Org link commands                                           :command:
| =C-c C-l= | =org-insert-link=         | Insert a link with a menu prompting for URL and description^* |
|           | =org-store-link=          | Store org link to headline in which the cursor is^*^*         |
|           | =org-toggle-link-display= | Toggles the way links are displayed                           |

.^* If the cursor is on a link, this will edit the link.

.^*^* After doing that, when inserting a link, you can leave the first field
blank and the link will point to where you stored.
*** Bullets
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Show nice bullets

Essential for easy tree viewing

#+begin_src emacs-lisp
(use-package org-bullets
  :ensure t
  :hook (org-mode . org-bullets-mode))
#+end_src

*** Exporting
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

- =ox-twbs= to export to beautiful HTML
- =ox-reveal= to export to Reveal.js presentation
- =ox-rst= to generate Restructured Text for sphinx documentation
- =ox-gfm= to generate github flavored markdown
- =htmlize= for colored code in all export formats

#+begin_src emacs-lisp
(use-package ox-gfm :ensure t)
(use-package ox-rst :ensure t)
(use-package ox-twbs :ensure t)
(use-package ox-reveal :ensure t
  :config (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
(use-package htmlize :ensure t)
(require 'ox-man)
(add-to-list 'org-export-backends 'gfm)
(add-to-list 'org-export-backends 'reveal)
#+end_src

**** Export keys                                                    :keys:

| =C-c C-e= | =org-export-dispatch= | Bring up the export menu |
In the export menu
| =R B= | =org-reveal-export-to-html-and-browse= | Present Right Now      |
| =h o= | =org-html-export-to-html=              | Straight-pipe HTML     |
| =r r= | =org-rst-export-to-rst=                | Restructured text      |
| =w o= | =org-twbs-export-to-html=              | Twitter Bootstrap html |
Except for =R B= the displayed LISP function does not open the file and the
dispatcher opens it after that function has run.
*** Babel
**** Babel Intro                                                    :keys:
Babel allows running of code blocks.  It is what enables this config to be in
orgmode format.

The ability to evaluate code in orgmode source blocks is built in with emacs but
must be activated to be used:

https://orgmode.org/worg/org-contrib/babel/languages/index.html#configure
| =C-c C-c= | =org-babel-execute-src-block= | When cursor is on an SRC block, execute its code |
**** Babel config
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
We simply add languages that we want to become available.  There are many more
but some of them require installing extra packages.

#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
			       '((shell . t)
				 (python . t)))
#+end_src

**** Disable prompt
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
As a security precaution this is off by default.  It would indeed be quite
surprising if your text editor runs a shell command if you accidently do =C-c
C-c=.

But if you know it exists, then there is no big deal.  Indeed one is not
surprised that a command runs when the press enter in a shell.

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

**** Disable babel on export
    :PROPERTIES:
    :HEADER-ARGS: :tangle no
    :END:

When tweaking the document and frequently exporting, it can be useful to not run
every block each time we export.

    #+begin_src emacs-lisp
    (setq org-export-use-babel t)
    #+end_src

With this setting, code blocks are not evaluated on export but if their output
is there, it will go in the export regardless of this setting.

***** Execute all command                                       :command:

| =C-c C-v C-b= | =org-babel-execute-buffer= | Evaluate all source blocks in the buffer (file) |

**** Set python3 as python interpreter
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(custom-set-variables '(org-babel-python-command "python3"))
#+end_src

#+begin_src python :results output
greeting = "Hello"
print(f'{greeting} world!')
#+end_src

#+RESULTS:
: Hello world!

*** Orgmode scratch buffer
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

    #+begin_src emacs-lisp
    (setq initial-major-mode 'org-mode)
    #+end_src

#+begin_src emacs-lisp
(setq initial-scratch-message "\
#+TITLE: Scratch Buffer
This buffer is for notes you don't want to save, in orgmode.
If you want to create a file, visit that file with C-x C-f,
then enter the text in that file's own buffer.

#+begin_src emacs-lisp

,#+end_src
")
#+end_src

#+RESULTS:
: # This buffer is for notes you don't want to save, in orgmode
: # If you want to create a file, visit that file with C-x C-f,
: # then enter the text in that file's own buffer.
: 
: #+begin_src emacs-lisp
: 
: #+end_src
    
*** Present GUI menu
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

  This adds the "Present" menu at the top with menu item "Present Now".

  #+begin_src emacs-lisp :results none
    (defun ox-reveal () (interactive) (org-reveal-export-to-html-and-browse nil t))
    (defun ox-twbs () (interactive) (browse-url (org-twbs-export-to-html nil t)))
    (defun ox-twbs-all () (interactive) (browse-url (org-twbs-export-to-html nil nil)))
    (defun ox-html () (interactive) (browse-url (org-html-export-to-html nil t)))
    (defun ox-html-all () (interactive) (browse-url (org-html-export-to-html nil nil)))
    (defun ox-rst () (interactive) (org-open-file (org-rst-export-to-rst nil t)))
    (defun ox-rst-all () (interactive) (org-open-file (org-rst-export-to-rst nil nil)))
    (easy-menu-define present-menu org-mode-map
      "Menu for word navigation commands."
      '("Present"
	["Present Right Now (C-c C-e R B)" org-reveal-export-to-html-and-browse]
	["Present Subtree Right Now (C-c C-e C-s R B)" ox-reveal]
	["View Twitter Bootstrap HTML Right now (C-c C-e C-s w o)" ox-twbs]
	["View Twitter Bootstrap HTML all Right now (C-c C-e w o)" ox-twbs-all]
	["View RST Right Now (C-c C-e C-s r R)" ox-rst]
	["View RST All Right Now (C-c C-e r R)" ox-rst-all]
	["View straight-pipe HTML Right Now (C-c C-e C-s h o)" ox-html]
	["View straight-pipe HTML All Right Now (C-c C-e h o)" ox-html-all]))
  #+end_src

*** Center cursor after shift-tab in orgmode
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
 Places the current line in the center of the screen after a =S-TAB= in orgmode.
 #+begin_src emacs-lisp
 (defun org-post-global-cycle () (interactive)
   (recenter)
   (org-beginning-of-line))
 (advice-add 'org-global-cycle
   :after #'org-post-global-cycle)
 #+end_src
 See [[help:advice-add]], basically, we can ask Emacs to add code to be run before
 and/or after an emacs function is run.

 You can use this to remove the "advice".
 #+begin_src emacs-lisp :tangle no
 (advice-remove 'org-global-cycle #'org-post-global-cycle)
 #+end_src

*** Startup visibility
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(custom-set-variables '(org-startup-folded t))
#+end_src
    
*** Inline images
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)
(setq org-image-actual-width 100)
#+end_src

*** Org-present with doom-theme
   :PROPERTIES:
   :HEADER-ARGS: :tangle no
   :END:

   #+begin_src emacs-lisp
(use-package org-present :ensure t)
   #+end_src
   
*** Babel Colorize RESULTS
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
From [[https://emacs.stackexchange.com/a/63562/19972][this Stack Overflow post by Erki der Loony]]

 #+begin_src emacs-lisp
 (defun ek/babel-ansi ()
   (when-let ((beg (org-babel-where-is-src-block-result nil nil)))
     (save-excursion
       (goto-char beg)
       (when (looking-at org-babel-result-regexp)
         (let ((end (org-babel-result-end))
               (ansi-color-context-region nil))
           (ansi-color-apply-on-region beg end))))))
 (add-hook 'org-babel-after-execute-hook 'ek/babel-ansi)
 #+end_src
 
*** Org indentation
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda () (electric-indent-mode 0) (org-indent-mode 1)))
#+end_src

Orgmode, please don't mess with me by indenting source blocks.
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
#+end_src

#+RESULTS:
: 0

*** Insert subheadings
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:
#+begin_src emacs-lisp
(defun org-insert-subheading-respect-content (arg)
  "Insert a new subheading and demote it.
Works for outline headings and for plain lists alike."
  (interactive "P")
  (org-insert-heading-respect-content arg)
  (cond ((org-at-heading-p) (org-do-demote))
        ((org-at-item-p) (org-indent-item))))
#+end_src

#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-S-<return>") 'org-insert-subheading-respect-content)
(define-key org-mode-map (kbd "M-S-<return>") 'org-insert-subheading)
#+end_src

#+RESULTS:
: org-insert-subheading

** Agenda
*** Agena files
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
**** Platform dependant =org-agenda-dir= variable
We use a single directory to hold our agenda files.  We create a symbol holding
that directory depending on the system we are on.
 #+begin_src emacs-lisp :results none
 (cond ((string-equal system-type "windows-nt") (setq org-agenda-dir
 ; "/plink:phc001@hpcr5-in:/fs/homeu2/eccc/cmd/cmds/phc001/Documents/gtd/"))
;; "C:\Users\Carphinp\OneDrive\Documents\gtd"))
 "C:/Users/Carphinp/OneDrive/Documents/gtd"))
       ((string-equal system-type "darwin") (setq org-agenda-dir
 "~/Documents/gtd"))
       ((string-equal system-type "gnu/linux") (setq org-agenda-dir
 "~/Documents/gtd")))
 #+end_src
 
Note: On Windows, =~= refers to something like
=C:\Users\CarphinP\AppData\Roaming\= rather than =C:\Users\CarphinP\=
**** Org agenda files
This is the variable that org looks at for files containing agenda items.
 #+begin_src emacs-lisp
 (setq org-agenda-files (list org-agenda-dir))
 #+end_src

**** Filename symbols
Create symbols holding the paths to GTD files
 #+begin_src emacs-lisp
 (setq gtd-in-tray-file (concat org-agenda-dir "/" "GTD_InTray.org")
       gtd-next-actions-file (concat org-agenda-dir "/" "GTD_NextActions.org")
       gtd-project-list-file (concat org-agenda-dir "/" "GTD_ProjectList.org")
       ;; gtd-work-project-list-file (concat org-agenda-dir "GTD_Work_ProjectList.org")
       gtd-reference-file (concat org-agenda-dir "/" "GTD_Reference.org")
       ;; gtd-work-reference-file (concat org-agenda-dir "GTD_Work_Reference.org")
       gtd-someday-maybe-file (concat org-agenda-dir "/" "GTD_SomedayMaybe.org")
       gtd-tickler-file (concat org-agenda-dir "/" "GTD_Tickler.org")
       gtd-journal-file (concat org-agenda-dir "/" "GTD_Journal.org")
       gtd-habits-file (concat org-agenda-dir "/" "GTD_Habits.org")
       gtd-email-file (concat org-agenda-dir "/" "GTD_Emails.org"))
 #+end_src
**** Quick access to GTD files
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
***** Commands
#+begin_src emacs-lisp
(defun gtd-open-in-tray              () (interactive) (find-file gtd-in-tray-file))
(defun gtd-open-project-list         () (interactive) (find-file gtd-project-list-file))
;; (defun gtd-open-work-project-list () (interactive) (find-file gtd-work-project-list-file))
(defun gtd-open-reference            () (interactive) (find-file gtd-reference-file))
(defun gtd-open-someday-maybe        () (interactive) (find-file gtd-someday-maybe-file))
;; (defun gtd-open-work-reference    () (interactive) (find-file gtd-work-reference-file))
(defun gtd-open-next-actions         () (interactive) (find-file gtd-next-actions-file))
(defun gtd-open-next-actions         () (interactive) (find-file gtd-next-actions-file))
(defun gtd-open-habits               () (interactive) (find-file gtd-habits-file))
(defun gtd-open-emails               () (interactive) (find-file gtd-email-file))
#+end_src

#+RESULTS:
: gtd-open-habits

***** Leader bindings
#+begin_src emacs-lisp
(define-prefix-command 'gtd)
(define-key leader-key (kbd "g") 'gtd)
(define-key gtd (kbd "c") 'org-capture)
(define-key gtd (kbd "i") 'gtd-open-in-tray)
(define-key gtd (kbd "h") 'gtd-open-habits)
(define-key gtd (kbd "p") 'gtd-open-project-list)
(define-key gtd (kbd "r") 'gtd-open-reference)
(define-key gtd (kbd "s") 'gtd-open-someday-maybe)
(define-key gtd (kbd "n") 'gtd-open-next-actions)
(define-key gtd (kbd "e") 'gtd-open-emails)
#+end_src

#+RESULTS:
: gtd-open-next-actions

#+REVEAL: split
*** Agenda Key
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
 I mapped a key because I like to pop in and out of it. I don't use it myself
 because the I put =org-agenda= on a keymap for my GTD stuff.

 #+begin_src emacs-lisp
(define-prefix-command 'org-agenda-keys)
(define-key leader-key (kbd "a") 'org-agenda-keys)
(define-key org-agenda-keys (kbd "a") 'org-agenda)
 #+end_src

*** Refile targets SUPER COOL!
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
Move items around with =org-refile=.  This controls how refile choices are presented.
 #+begin_src emacs-lisp
 (setq org-refile-targets '((nil :maxlevel . 3) (org-agenda-files :maxlevel . 3)))
 (setq org-outline-path-complete-in-steps nil)
 (setq org-refile-use-outline-path 'file)
 #+end_src

 Ref : https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html

**** Keys                                                           :keys:
    | =C-c C-w=     | =org-refile= | Move headline under cursor to somewhere else |
    | =C-u C-c C-w= | =org-refile= | Go to selected target (no real refiling)     |
*** Capture templates
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
The function =org-capture= allows for quick capturing of notes with configurable
templates.
 #+begin_src emacs-lisp
       (setq org-capture-templates
	 '(("i" "GTD Input" entry (file gtd-in-tray-file)
	    "* GTD-IN %?\n %i\n %a" :kill-buffer t)
	   ("c" "Emacs config" entry (file emacs-config-file)
	    "* GTD-IN %?\n %i\n %a" :kill-buffer t)))
 #+end_src

*** Capture hotkey
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
#+begin_src emacs-lisp
(defun org-capture-input () (interactive) (org-capture nil "i"))
(global-set-key (kbd "C-c c") 'org-capture-input)
#+end_src
**** Keys                                                           :keys:
| =C-c C-w= | =org-capture-input= | (Custom) Org apture with selected template "i". |

*** Agenda display control
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

Don't show the file and control spacing so that all entries are aligned.

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format  '((agenda . "    %-12t%-12s")))
#+end_src

#+RESULTS:
: ((agenda .     %-12t%-12s))

*** Keys                                                             :keys:

    | =f,b=   | Forward, backward in time              |
    | =n,p=   | Next, previous line                    |
    | =d=     | Switch to day view                     |
    | =w=     | Switch to week view                    |
    | =m=     | Mark entry                             |
    | =B=     | Do bulk action to marked entries       |
    | =C-u B= | Do bulk action with universal argument |

*** Org Habits
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Advanced orgmode and GTD
**** Customizations from a post
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

A small customization from  [[https://cpbotha.net/2019/11/02/forming-and-maintaining-habits-using-orgmode/][this post]]
#+begin_src emacs-lisp
;; Log TODO creation
(setq org-treat-insert-todo-heading-as-state-change t)
;; log into LOGBOOK drawer
(setq org-log-into-drawer t)
#+end_src

**** Todo keywords for GTD
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

The first set of keywords is a generic set of keywords that I can give TODO
keywords to items without having them be part of my GTD.

The GTD-* keywords map to the various things that what David Allen calls "stuff"
can be.

#+begin_src emacs-lisp
(setq org-todo-keywords '((sequence "TODO" "WAITING" "VERIFY" "|" "DONE")
			  (sequence
			     "GTD-IN(i)"
			     "GTD-CLARIFY(c)"
			     "GTD-PROJECT(p)"
			     "GTD-SOMEDAY-MAYBE(s)"
			     "GTD-ACTION(a)"
			     "GTD-NEXT-ACTION(n)"
			     "GTD-WAITING(w)"
			     "|"
			     "GTD-REFERENCE(r)"
			     "GTD-DELEGATED(g)"
			     "GTD-DONE(d)")))

(setq org-todo-keyword-faces
   '(("GTD-IN" :foreground "#ff8800" :weight normal :underline t :size small)
     ("GTD-PROJECT" :foreground "#0088ff" :weight bold :underline t)
     ("GTD-ACTION" :foreground "#0088ff" :weight normal :underline nil)
     ("GTD-NEXT-ACTION" :foreground "#0088ff" :weight bold :underline nil)
     ("GTD-WAITING" :foreground "#aaaa00" :weight normal :underline nil)
     ("GTD-REFERENCE" :foreground "#00ff00" :weight normal :underline nil)
     ("GTD-SOMEDAY-MAYBE" :foreground "#7c7c74" :weight normal :underline nil)
     ("GTD-DONE" :foreground "#00ff00" :weight normal :underline nil)))
#+end_src

#+RESULTS:
| GTD-IN            | :foreground | #ff8800 | :weight | normal | :underline | t   | :size | small |
| GTD-PROJECT       | :foreground | #0088ff | :weight | bold   | :underline | t   |       |       |
| GTD-ACTION        | :foreground | #0088ff | :weight | normal | :underline | nil |       |       |
| GTD-NEXT-ACTION   | :foreground | #0088ff | :weight | bold   | :underline | nil |       |       |
| GTD-WAITING       | :foreground | #aaaa00 | :weight | normal | :underline | nil |       |       |
| GTD-REFERENCE     | :foreground | #00ff00 | :weight | normal | :underline | nil |       |       |
| GTD-SOMEDAY-MAYBE | :foreground | #7c7c74 | :weight | normal | :underline | nil |       |       |
| GTD-DONE          | :foreground | #00ff00 | :weight | normal | :underline | nil |       |       |

  #+REVEAL: split
**** Definition of stuck projects
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

In GTD projects are called "stuck" if they do not contain a =GTD-NEXT-ACTION=.
This says that a stuck project is a headline where the todo keyword is
=GTD-PROJECT= that do not contain a heading matching =GTD-NEXT-ACTION=.

#+begin_src emacs-lisp
(setq org-stuck-projects
      '("TODO=\"GTD-PROJECT\"" ;; Search query
	("GTD-NEXT-ACTION")    ;; Not stuck if contains
	()                     ;; Stuck if contains
	""))                   ;; General regex
#+end_src

**** Date interval for agenda view
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

The default is kind of annoying.  It shows a week starting on a Sunday but what
is annoying about that is that on Sunday, the agenda won't show what you have
tomorrow!

The way this is set, it will show 7 days starting 2 days in the past.

#+begin_src emacs-lisp :results none
(setq org-agenda-span 9
      org-agenda-start-on-weekday 0
      org-agenda-start-day "-2d")
#+end_src

**** Agenda custom commands
   These depend on my todo keywords so they are not part of the basic agenda config.
***** Definition
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" "Complete agenda view"
         ((tags "PRIORITY=\"A\"")
          (tags "PRIORITY=\"C\"")
          (stuck "")
          (agenda "" )
          (todo "GTD-ACTION")))
        ("s" "Split agenda view"
         ((agenda "" ((org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))))
          (agenda "" ((org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))))
          (agenda "" ((org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))))))
        ("h" "Habits" tags "STYLE=\"habit\"" ((org-agenda-overriding-header "Habits")))
        ("g" . "GTD keyword searches searches")
        ("gi" todo "GTD-IN")
        ("gc" todo "GTD-CLARIFY")
        ("ga" todo "GTD-ACTION")
        ("gn" todo-tree "GTD-NEXT-ACTION")
        ("gp" todo "GTD-PROJECT")))
#+end_src

Run the agenda with "c" custom command.
 
***** Agenda view commands
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
This is equivalent to launching =org-agenda= and pressing a.
#+begin_src emacs-lisp
(defun gtd-agenda-view () (interactive)
  (org-agenda nil "a"))
#+end_src
#+begin_src emacs-lisp
(defun gtd-habits-view () (interactive)
  (org-agenda nil "h"))
#+end_src
#+begin_src emacs-lisp
(defun gtd-review-view () (interactive)
  (org-agenda nil "c"))
#+end_src

#+begin_src emacs-lisp
(defun gtd-next-action-sparse-tree () (interactive)
  (find-file gtd-project-list-file)
  (org-agenda nil "gn"))
#+end_src

#+begin_src emacs-lisp
(defun gtd-work-next-action-sparse-tree () (interactive)
  (find-file gtd-work-project-list-file)
  (org-agenda nil "gn"))
#+end_src

#+RESULTS:
: gtd-work-next-action-sparse-tree

***** Agenda view hotkeys
    :PROPERTIES:
    :HEADER-ARGS: :tangle yes
    :END:
     Warning: This overrides the binding [[*Agenda Key][Agenda Key]] and makes the key =C-c a= a
non-prefix key.

#+begin_src emacs-lisp
(define-key org-agenda-keys (kbd "g") 'gtd-agenda-view)
(define-key org-agenda-keys (kbd "h") 'gtd-habits-view)
(define-key org-agenda-keys (kbd "c") 'gtd-review-view)
(define-key org-agenda-keys (kbd "n") 'gtd-next-action-sparse-tree)
(define-key org-agenda-keys (kbd "w n") 'gtd-work-next-action-sparse-tree)
#+end_src

***** Always show graph
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:
From https://emacs.stackexchange.com/a/17328/19972
#+begin_src emacs-lisp
(defvar my/org-habit-show-graphs-everywhere t
  "If non-nil, show habit graphs in all types of agenda buffers.

Normally, habits display consistency graphs only in
\"agenda\"-type agenda buffers, not in other types of agenda
buffers.  Set this variable to any non-nil variable to show
consistency graphs in all Org mode agendas.")

(defun my/org-agenda-mark-habits ()
  "Mark all habits in current agenda for graph display.

This function enforces `my/org-habit-show-graphs-everywhere' by
marking all habits in the current agenda as such.  When run just
before `org-agenda-finalize' (such as by advice; unfortunately,
`org-agenda-finalize-hook' is run too late), this has the effect
of displaying consistency graphs for these habits.

When `my/org-habit-show-graphs-everywhere' is nil, this function
has no effect."
  (when (and my/org-habit-show-graphs-everywhere
         (not (get-text-property (point) 'org-series)))
    (let ((cursor (point))
          item data) 
      (while (setq cursor (next-single-property-change cursor 'org-marker))
        (setq item (get-text-property cursor 'org-marker))
        (when (and item (org-is-habit-p item)) 
          (with-current-buffer (marker-buffer item)
            (setq data (org-habit-parse-todo item))) 
          (put-text-property cursor
                             (next-single-property-change cursor 'org-marker)
                             'org-habit-p data))))))

(advice-add #'org-agenda-finalize :before #'my/org-agenda-mark-habits)
#+end_src

See also : https://www.reddit.com/r/orgmode/comments/efrcoe/orghabit_graph_not_aligned_properly/

**** Closing notes
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
#+begin_src emacs-lisp :results none
(setq org-log-done 'note)
#+end_src
**** Agenda mode map customization
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

I want to learn Emacs keybindings for most things so I don't want to evilify
every single mode out there.

However, doing =j= and =k= is a hard habbit to lose.  So I just remap the keys
to print a message.
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook (lambda ()
(define-key org-agenda-mode-map (kbd "j") (lambda () (interactive)
  (message "- Lamont Cranston: Do you have any idea who you just kidnapped?
- Tulku: Cranston; Lamont Cranston.
- Lamont Cranston: You know my real name?
- Tulku: Yes. I also know that for as long as you can remember,
	 you struggled against your own black heart and always lost. You
	 watched your sprit, your very face change as the beast claws its
	 way out from within you.
j is deactivated
It normally does org-agenda-goto-date")))))
;; Originally org-agenda-capture : I use C-c c and I can't use k
(add-hook 'org-agenda-mode-hook (lambda ()
  (define-key org-agenda-mode-map (kbd "k") (lambda () (interactive)
    (message " The Shadow: I saved your life, Roy Tam. It now belongs to me.
- Dr. Tam: It does?
k is deactivated
It normally does org-agenda-capture (do C-h f to find out what key it is)")))))
#+end_src


#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook (lambda ()
  (define-key org-agenda-mode-map (kbd "SPC") 'leader-key)))
#+end_src

**** Search result visibility
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
This makes the sparse tree when doing =gtd-next-action-sparse-tree= be all
collapsed with only the ancestors.

But in the config, when I run the s-expression at the start, it will show the
content of the results (key tables mostly) and we can =C-c C-e C-v h o= to
export only what is visible to html.  (Or one could export to .org as a way of
"extracting" a sparse tree.

#+begin_src emacs-lisp
(custom-set-variables
 '(org-show-context-detail
   '((occur-tree . ancestors)
     (default . local))))
#+end_src

**** System Crafter's org-present config 
    :PROPERTIES:
    :HEADER-ARGS: :tangle no
    :END:

   From System-crafter's config.  
     #+begin_src emacs-lisp
     (defun dw/org-present-prepare-slide ()
     (org-overview)
     (org-show-entry)
     (org-show-children))

   (defun dw/org-present-hook ()
     (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
					(header-line (:height 4.5) variable-pitch)
					(org-code (:height 1.55) org-code)
					(org-verbatim (:height 1.55) org-verbatim)
					(org-block (:height 1.25) org-block)
					(org-block-begin-line (:height 0.7) org-block)))
     (setq header-line-format " ")
     (org-display-inline-images)
     (dw/org-present-prepare-slide))

   (defun dw/org-present-quit-hook ()
     (setq-local face-remapping-alist '((default variable-pitch default)))
     (setq header-line-format nil)
     (org-present-small)
     (org-remove-inline-images))

   (defun dw/org-present-prev ()
     (interactive)
     (org-present-prev)
     (dw/org-present-prepare-slide))

   (defun dw/org-present-next ()
     (interactive)
     (org-present-next)
     (dw/org-present-prepare-slide))

   (use-package org-present
     :bind (:map org-present-mode-keymap
            ("C-c C-j" . dw/org-present-next)
            ("C-c C-k" . dw/org-present-prev))
     :hook ((org-present-mode . dw/org-present-hook)
            (org-present-mode-quit . dw/org-present-quit-hook)))
     #+end_src

     
**** Specific agenda files

Functions for creating agenda views from a certain set of files.  This is done
by using =let= to temporarily set =org-agenda-files=.

***** Generic function
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(defun phc-restricted-agenda-list (agenda-files)
  (let ((org-agenda-files agenda-files))
    (org-agenda-list)))
#+end_src
***** Export and publish my agenda views
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

#+begin_src emacs-lisp
(defun publish-work-agenda-views () (interactive)
       (let ((org-agenda-files (list
				"~/Documents/gtd/GTD_Work_Reference.org"
				"~/Documents/gtd/GTD_Work_ProjectList.org"
                                "~/Documents/gtd/GTD_Work_Habits.org"))
	     (org-agenda-span 40)
	     (org-agenda-start-day "-5d"))
	 (org-agenda-list)
	 (org-agenda-write "/ssh:ppp4:/home/phc001/public_html/files/phil-agenda-from-home.html")
	 (org-agenda-write "/ssh:apt-imac:/Users/pcarphin/Documents/GitHub/phil-website/server/resources/public/phil-work-agenda.html")
	 (shell-command "scp ~/Documents/gtd/GTD_Work_ProjectList.org ppp4:~/public_org/GTD_Work_ProjectList.org")
	 (shell-command "scp ~/Documents/gtd/GTD_Work_Reference.org ppp4:~/public_org/GTD_Work_Reference.org")))
#+end_src

#+RESULTS:
: publish-work-agenda-views

***** Work Agenda view
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(defun work-agenda-view () (interactive)
       (phc-restricted-agenda-list (list "~/Documents/gtd/GTD_Work_Reference.org"
					 "~/Documents/gtd/GTD_Work_ProjectList.org")))
(defun for000-agenda-view () (interactive)
       (phc-restricted-agenda-list (list "/ssh:ppp4:/home/for000/Documents/gtd")))
#+end_src

***** Keys
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:
#+begin_src emacs-lisp
(define-key org-agenda-keys (kbd "w v") 'work-agenda-view)
(define-key org-agenda-keys (kbd "w f") 'for000-agenda-view)
(define-key org-agenda-keys (kbd "w p") 'publish-work-agenda-views)
#+end_src

| =SPC a w v= | =work-agenda-view= |
| =SPC a w f= | =for000-agenda-view= |
| =SPC a w f= | =for000-agenda-view= |

**** Open phil's agenda
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

This requires only stock emacs

#+begin_src emacs-lisp
(defun phc001-agenda-view () (interactive)
       (let ((org-agenda-files (list "/ssh:ppp4:/home/phc001/public_org/")))
	 (org-agenda-list)))
#+end_src
* Leader Keymap
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:
Structured keymap inspired by spacemacs. The leader key is =M-m= and =SPC= in
evil normal mode.
** Emacs leader key
#+begin_src emacs-lisp
(global-set-key (kbd "M-m") 'leader-key)
#+end_src
** =M-x=
Same as Spacemacs.
#+begin_src emacs-lisp
(define-key leader-key (kbd "SPC") 'helm-M-x)
(define-key leader-key (kbd "M-m") 'helm-M-x)
#+end_src

** Window keymap

#+begin_src emacs-lisp
(windmove-default-keybindings)
(define-prefix-command 'window-commands)
(define-key leader-key (kbd "w") 'evil-window-map)
(define-key evil-window-map (kbd "0") 'delete-window)
(define-key evil-window-map (kbd "1") 'delete-other-windows)
(define-key evil-window-map (kbd "z") 'delete-other-windows)
(define-key evil-window-map (kbd "m") 'delete-other-windows)
(define-key evil-window-map (kbd "/") 'split-window-right)
(define-key evil-window-map (kbd "é") 'split-window-right)
(define-key evil-window-map (kbd "-") 'split-window-below)
(define-key evil-window-map (kbd "f") 'find-file-other-window)
(define-key evil-window-map (kbd "<right>") 'windmove-right)
(define-key evil-window-map (kbd "<left>") 'windmove-left)
(define-key evil-window-map (kbd "<up>") 'windmove-up)
(define-key evil-window-map (kbd "<down>") 'windmove-down)
#+end_src

#+RESULTS:
: windmove-down

** About this keymap
#+begin_src emacs-lisp
(defun about-this-keymap () (interactive)
(org-open-link-from-string "[[file:~/.emacs.d/config.org::Leader Keymap]]"))
#+end_src

How meta is it that we have a function whose implementation takes us to
see its implementation!

** Emacs movement

#+begin_src emacs-lisp
(define-prefix-command 'emacs-movement)
(define-key leader-key (kbd "m") 'emacs-movement)
(define-key emacs-movement (kbd "C-f") 'forward-char)
(define-key emacs-movement (kbd "C-b") 'backward-char)
(define-key emacs-movement (kbd "C-p") 'previous-line)
(define-key emacs-movement (kbd "C-n") 'next-line)
(define-key emacs-movement (kbd "C-v") 'scroll-up-command)
(define-key emacs-movement (kbd "M-v") 'scroll-down-command)
(define-key emacs-movement (kbd "C-s") 'isearch-forward)
(define-key emacs-movement (kbd "C-r") 'isearch-backward)
#+end_src

** Files

#+begin_src emacs-lisp
(defun open-emacs-config-file () (interactive) (find-file "~/.emacs.d/config.org"))
(define-prefix-command 'files)
(define-key leader-key (kbd "f") 'files)

(define-key files (kbd "c") 'open-emacs-config-file)
(define-key files (kbd "f") 'helm-find-files)
(define-key files (kbd "w") 'find-file-other-window)
(define-key files (kbd "r") 'helm-recentf)
(define-key files (kbd "s") 'save-buffer)
#+end_src

** Buffers
#+begin_src emacs-lisp
(defun open-scratch () (interactive)
       (switch-to-buffer "*scratch*"))
#+end_src

#+begin_src emacs-lisp
(define-prefix-command 'buffers)
(define-key leader-key (kbd "b") 'buffers)
(define-key buffers (kbd "b") 'helm-buffers-list)
(define-key buffers (kbd "k") 'kill-buffer)
(define-key buffers (kbd "K") 'maybe-kill-all-buffers)
(define-key buffers (kbd "s") (lambda () (interactive) (switch-to-buffer "*scratch*")))
(define-key buffers (kbd "p") 'switch-to-prev-buffer)
(define-key buffers (kbd "n") 'switch-to-next-buffer)
(define-key buffers (kbd "o") 'mode-line-other-buffer)
#+end_src

** Save and quit
#+begin_src emacs-lisp
(define-key leader-key (kbd "q") 'save-buffers-kill-emacs)
#+end_src
** Help
#+begin_src emacs-lisp
(define-prefix-command 'help)
(define-key leader-key (kbd "h") 'help)
(define-key help (kbd "a") 'about-this-keymap)
(define-key help (kbd "C-i") 'helm-info)
(define-key help (kbd "o") 'describe-symbol)
(define-key help (kbd "f") 'describe-function)
(define-key help (kbd "k") 'describe-key)
#+end_src
** Orgmode
#+begin_src emacs-lisp
(define-prefix-command 'orgmode)
#+end_src
*** Subset of C-c commands
#+begin_src emacs-lisp
(define-prefix-command '__orgmode__C-c__)
(define-key orgmode (kbd "C-c") '__orgmode__C-c__)
(define-key __orgmode__C-c__ (kbd "C-,") 'org-insert-structure-template)
(define-key __orgmode__C-c__ (kbd "C-c") 'org-ctrl-c-ctrl-c)
(define-key __orgmode__C-c__ (kbd "C-w") 'org-refile)
(define-key __orgmode__C-c__ (kbd "C-x C-c") 'org-columns)
(define-key __orgmode__C-c__ (kbd "'") 'org-edit-special)
(define-key __orgmode__C-c__ (kbd ".") 'org-time-stamp)
(define-key __orgmode__C-c__ (kbd "C-s") 'org-schedule)
(define-key __orgmode__C-c__ (kbd "C-d") 'org-deadline)
#+end_src

*** Orgmode favorites
#+begin_src emacs-lisp
(define-key leader-key (kbd "o") 'orgmode)
(define-key orgmode (kbd "a") 'org-agenda)
(define-key orgmode (kbd "v") 'org-tags-view)
(define-key orgmode (kbd "C-c /") 'org-match-sparse-tree)
(define-key orgmode (kbd "<M-S-left>") 'org-promote-subtree)
(define-key orgmode (kbd "<M-S-right>") 'org-demote-subtree)
(define-key orgmode (kbd "<M-up>") 'org-demote-subtree)
(define-key orgmode (kbd "n") 'org-narrow-to-subtree)
(define-key orgmode (kbd "c") 'org-columns)
#+end_src
*** Item insertion
#+begin_src emacs-lisp
(define-prefix-command 'org-insert)
(define-key orgmode (kbd "i") 'org-insert)
(define-key 'org-insert (kbd "h") 'org-insert-heading)
(define-key 'org-insert (kbd "H") 'org-insert-heading-respect-content)
(define-key 'org-insert (kbd "s") 'org-insert-subheading)
(define-key 'org-insert (kbd "S") 'org-insert-subheading-respect-content)
#+end_src

*** Subtree movement and promotions
#+begin_src emacs-lisp
(define-prefix-command 'org-subtree)
(define-key orgmode (kbd "s") 'org-subtree)
(define-key 'org-subtree (kbd "h") 'org-promote-subtree)
(define-key 'org-subtree (kbd "l") 'org-demote-subtree)
(define-key 'org-subtree (kbd "k") 'org-move-subtree-up)
(define-key 'org-subtree (kbd "j") 'org-move-subtree-down)
#+end_src

***** Explanations

  La touche =C-|= (=C-S-\=) est une map de touches qui contient des
  fonctionnalité spécialement sélectionnées.

  Le choix de touche de départ est de choisr un binding qui fait chier à faire.

  Le but c'est d'explorer.  Quand on trouve quelque chose qu'on aime, on peut
  découvrir les bindings standards en faisant =C-h f= et écrire le nom de la
  fonction exécutée par la touche.  Ou faire =C-h k= et refaire la touche et
  l'aide nous dira quels sont les autres bindings pour la fonctionnalité.

  Si un binding a le même nom que la fonction comme =C-h=, c'est que ce groupe est
  une sélection des fonctions disponibles en faisant =C-h= normalement.

  Si le groupe contient le mot mode, c'est qu'il contient des fonctions qui sont
  seulement disponibles dans un certain mode.

  Les touches utilisées sont le plus souvent possible la même touche qu'on ferait
  normalement. Par exemple, =C-| o C-c C-,= insère un bloc de code source.  Le
  choix est fait comme ça parce que la touche =C-c C-,= est la touche native pour
  faire cette action.


***** Keys                                                             :keys:
| ~C-|~ | =prefix-key= | A grouping of common basic keys |

*** Org present
#+begin_src emacs-lisp
(define-prefix-command 'org-present-map)
(define-key leader-key (kbd "p") 'org-present-map)
(define-key org-present-map (kbd "P") 'org-present)
(define-key org-present-map (kbd "n") 'org-present-next)
(define-key org-present-map (kbd "p") 'org-present-prev)
(define-key org-present-map (kbd "b") 'org-present-big)
(define-key org-present-map (kbd "s") 'org-present-small)
(define-key org-present-map (kbd "q") 'org-present-quit)
#+end_src


*** Org Time Commands
:LOGBOOK:
CLOCK: [2021-04-14 Wed 23:57]
:END:
#+begin_src emacs-lisp
(define-prefix-command 'org-time-commands)
(define-key leader-key (kbd "t") 'org-time-commands)
(define-key org-time-commands (kbd "s") 'org-schedule)
(define-key org-time-commands (kbd "d") 'org-deadline)

(define-prefix-command 'org-clocking-commands)
(define-key org-time-commands (kbd "c") 'org-clocking-commands)
(define-key org-clocking-commands (kbd "i") 'org-clock-in)
(define-key org-clocking-commands (kbd "o") 'org-clock-out)
(define-key org-clocking-commands (kbd "l") 'org-clock-in-last)
(define-key org-clocking-commands (kbd "g") 'org-clock-goto)
(define-key org-clocking-commands (kbd "r") 'org-clock-report)
#+end_src

#+RESULTS:
: org-clock-in-last


** Vterm

Moved to section =Other stuff/Vterm= to be in a single =(cond ((not "On windows")(...)))=

* Other stuff
** Languages
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(use-package yaml-mode :ensure t)
(use-package ssh-config-mode :ensure t)
(use-package cmake-mode :ensure t)
(use-package vimrc-mode :ensure t)
(use-package markdown-mode :ensure t)
(use-package go-mode :ensure t)
#+end_src

** Buffer cleanup
  :PROPERTIES:
  :HEADER-ARGS: :tangle yes
  :END:

  #+begin_src emacs-lisp
;; ref : https://www.emacswiki.org/emacs/KillingBuffers#toc2
(setq not-to-kill-buffer-list '("#emacs" "irc.freenode.net:6667" "recentf"))
(defun maybe-kill-buffer (buffer)
  (let ((bname (buffer-name buffer)))
    (unless (or (member bname not-to-kill-buffer-list)
                (get-buffer-window buffer 'visible)
                (cl-search "*" bname)
                (cl-search "magit" bname))
      (kill-buffer-ask buffer))))
(defun maybe-kill-all-buffers ()
  (interactive)
  (mapc 'maybe-kill-buffer (delq (current-buffer) (buffer-list))))
(defun almost-quit-emacs ()
  (interactive)
  (mapc 'maybe-kill-buffer (buffer-list))
  (delete-frame))
(defun kill-invisible-buffers ()
  (interactive)
  (dolist (buf (buffer-list))
    (unless (get-buffer-window buf 'visible) (maybe-kill-buffer buf))))
  #+end_src

** Magit
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

 The most amazing vim plugin in existence.

 #+begin_src emacs-lisp
 (use-package magit
   :ensure t
   :custom
   (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
   (custom-set-variables '(magit-save-repository-buffers 'dontask))
 #+end_src

 #+RESULTS:
 
** Yasnippet
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:
 Note: package =yasnippet= doesn't come with the library of snippets but
 =yasnippet-snippets= comes with them and has =yasnippet= as a dependency
 therefore we only need to install this one.
 #+begin_src emacs-lisp :results none
 (use-package yasnippet-snippets
   :ensure t
   :config (yas-global-mode 1))
 #+end_src

** RSS
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

 From [[https://gerlacdt.github.io/posts/emacs-elfeed/][Emacs as an RSS reader]]

 #+begin_src emacs-lisp :results none
 ;; data is stored in ~/.elfeed
 (use-package elfeed :ensure t)
 (setq elfeed-feeds
       '(
	 ;; programming
	 ("https://news.ycombinator.com/rss" hacker)
	 ("https://www.heise.de/developer/rss/news-atom.xml" heise)
	 ("https://www.reddit.com/r/programming.rss" programming)
	 ("https://www.reddit.com/r/emacs.rss" emacs)

	 ;; programming languages
	 ("https://www.reddit.com/r/golang.rss" golang)
	 ("https://www.reddit.com/r/java.rss" java)
	 ("https://www.reddit.com/r/javascript.rss" javascript)
	 ("https://www.reddit.com/r/typescript.rss" typescript)
	 ("https://www.reddit.com/r/clojure.rss" clojure)
	 ("https://www.reddit.com/r/python.rss" python)

	 ;; cloud
	 ("https://www.reddit.com/r/aws.rss" aws)
	 ("https://www.reddit.com/r/googlecloud.rss" googlecloud)
	 ("https://www.reddit.com/r/azure.rss" azure)
	 ("https://www.reddit.com/r/devops.rss" devops)
	 ("https://www.reddit.com/r/kubernetes.rss" kubernetes)
 ))

 (setq-default elfeed-search-filter "@2-days-ago +unread")
 (setq-default elfeed-search-title-max-width 100)
 (setq-default elfeed-search-title-min-width 100)
 #+end_src
 
** Ergoemacs
   :PROPERTIES:
   :HEADER-ARGS: :tangle no
   :END:

 [[https://ergoemacs.github.io][ergoemacs-mode website]]
    #+begin_src emacs-lisp
    (use-package ergoemacs-mode :ensure t
      :config (setq ergoemacs-theme nil)
              (setq ergoemacs-keyboard-layour "us")
              (ergoemacs-mode 1))
    #+end_src
** Doom themes
   :PROPERTIES:
   :HEADER-ARGS: :tangle no
   :END:

 #+begin_src emacs-lisp
 (use-package doom-themes :ensure t
   :config
   ;; Global settings (defaults)
   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
         doom-themes-enable-italic t) ; if nil, italics is universally disabled
   (load-theme 'doom-one t)

   ;; Enable flashing mode-line on errors
   (doom-themes-visual-bell-config)
  
   ;; Enable custom neotree theme (all-the-icons must be installed!)
   (doom-themes-neotree-config)
   ;; or for treemacs users
   (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
   (doom-themes-treemacs-config)
  
   ;; Corrects (and improves) org-mode's native fontification.
   (doom-themes-org-config))
 #+end_src

 - Ephemeral
 - Solarized-dark
 - sourcerer

** keyfreq Key frequency data
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

   #+begin_src emacs-lisp
   (use-package keyfreq :ensure t
     :config
     (keyfreq-mode 1)
     (keyfreq-autosave-mode 1)
     (setq keyfreq-excluded-commands
           '(self-insert-command
             forward-char
             backward-char
             previous-line
             next-line))
     :custom
     (keyfreq-file "~/.emacs.d/keyfreq")
     )

   #+end_src

** command-log-mode
   :PROPERTIES:
   :HEADER-ARGS: :tangle yes
   :END:

 #+begin_src emacs-lisp
 (use-package command-log-mode :ensure t)
 #+end_src
**** Commands                                                       :command:
 | =global-command-log-mode=     | Activate command logging                   |
 | =clm/open-command-log-buffer= | Open command log buffer for demonstrations |
 
** Modus themes
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_quote
Accessible themes for GNU Emacs, conforming with the highest standard for colour contrast between background and foreground values (WCAG AAA) - [[https://protesilaos.com/modus-themes/][Modus Themes]]
#+end_quote

#+begin_src emacs-lisp
(use-package modus-themes :ensure t)
(custom-set-variables
 '(custom-enabled-themes '(modus-vivendi))
 '(custom-safe-themes
   '("c7f364aeea0458b6368815558cbf1f54bbdcc1dde8a14b5260eb82b76c0ffc7b" default)))
#+end_src

I am not loading the theme because I want to continue with built-in themes for now.

** =sg-lisp.el=
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:


#+begin_src emacs-lisp
;; Package pour se déplacer uniquement dans du code elisp
(use-package paredit
  :ensure t
  :delight
  :config
  (cl-loop for mode-hook in '(lisp-mode-hook
			      lisp-interaction-mode-hook
			      eval-expression-minibuffer-setup-hook
			      emacs-lisp-mode-hook)
	   do (add-hook mode-hook 'enable-paredit-mode)))

;; Coloration syntaxique pour éditer du elisp
(use-package highlight-defined
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook 'highlight-defined-mode))

(use-package aggressive-indent
  :ensure t
  :delight
  :config
  ;; Je ne veux pas que ça soit actif par défaut
  (global-aggressive-indent-mode -1))

(add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    ;; Le tiret constitue un mot en soit (pour w et b).
	    (modify-syntax-entry ?- "w")
	    ;; goto symbol
	    (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions)
	    (aggressive-indent-mode 1)))

(provide 'sg-lisp)
#+end_src

#+RESULTS:
: sg-lisp

** Vterm
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

Note that the first time you run =vterm= it will want to compile stuff.

On UNIX systems it should work fine, UNIX running on a mac M1, make sure to have
a very recent version of CMake.

#+begin_src emacs-lisp
(cond ((not (string-equal system-type "windows-nt"))
       (use-package vterm
         :ensure t
         :config (progn (define-key leader-key (kbd "v") 'vterm)
                        (add-hook 'vterm-mode-hook (lambda () (global-hl-line-mode -1)))))))
#+end_src

#+RESULTS:
: t

* Documentation
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
** Emacs Basic keys
*** Directional movement

Character/line movements
#+begin_example
               previous-line
                    C-p
                     ^
                     |
backward-char C-b <--+-->C-f forward-cher
                     |
                     v
                    C-n
                 next-line
#+end_example

Line Start =C-a= <--> =C-e= Line End

Search backward =C-r= \leftrightarrow =C-s= Search forward

Buffer start =M-<= (=M-S-,=) \leftrightarrow =M->= (=M-S-.=) Buffer end

*** Mark

Setting the mark in Emacs is like starting a visual selection in Vim.

Cutting is called "killing" in emacs (=kill-line=, =kill-region=, ...) and
pasting is called "yanking".  "You kill text which deletes it and puts it into
the kill ring.  Then you yank text from the kill-ring and put it into the
buffer".

| =C-<SPC>= | =set-mark-command= | Start a visual selection |
| =M-w=     | =kill-ring-save=   | Copy without deleting    |
| =C-g=     | =keyboard-quit=    | Cancel visual selection  |
| =C-w=     | =kill-region=      | Copy and delete          |
| =M-d=     | =kill-word=        | Cut word                 |
| =C-k=     | =kill-line=        | Cut line                 |

*** Undo/Redo

| C-/    | undo |
| C-_    | undo |
| s-z    | undo |
| C-/    | undo |
| C-x u  | undo |
| <undo> | undo |

There is no undo https://www.youtube.com/watch?v=nY64e1SqrbU


** Things to do with orgmode

*** Write headlines and collapse them                           :keys:syntax:

 | =S-8=   | Insert a star character |
 | =TAB=   | =org-cycle=             |
 | =S-TAB= | =org-global-cycle=      |

 The key =S-TAB= is bound to =org-shifttab= which calls =org-global-cycle= if the
 cursor is not in a table.

*** Write inline markup                                         :keys:syntax:
 | ~=~ | code      |
 | ~*~ | bold      |
 | ~_~ | Underline |
 | ~/~ | Italic    |
 | =~= | Verbatim  |
*** Write dates like this <2021-03-02> or <2021-03-02 8:00>          :syntax:
*** Write source blocks and maybe execute them =C-c C-,=        :keys:syntax:
*** Export your stuff to all the formats =C-c C-e=                     :keys:
*** Move headlines around with refile =C-c C-w=                        :keys:
*** Move headlines around with arrows                                  :keys:
     | M-<left/right> | =org-promote-subtree=, =org-demote-subtree= | Change headline level of subtree (and it's children recursively)            |
     | M-<up/down>    | =org-meta-up=, =org-meta-down=              | With the cursor on a headline, exchange it with it's prececing/next sibling |
*** Assign tags to headlines =C-c C-q=                                 :keys:
*** Search by tags =M-x org-tags-view=                                 :keys:
*** Sparse trees =C-c /=                                               :keys:
*** Tags sparse trees =C-c \=                                          :keys:
*** Column view                                                        :keys:
 Look at the =#+COLUMNS:= property in this document.
 |=C-c C-x C-c= | =org-columns= | Switch to a really useful view for consulting and editing properties |
 *NOTE* How much of the document will go into column-view depends on where your
  cursor is.  If you want the whole document, then you have to get your cursor to
  the top of the file before pressing =C-c C-x C-c=.
*** Agenda view =M-x org-agenda RET=                                :command:
    If anything has a date in it, it will show up in the agenda on that day.
*** Use =SCHEDULED:= and =DEADLINE:= for planning

 Using =SCHEDULED:= makes things appear in green in that day in the agenda.

 Items marked with =DEADLINE: <2021-02-26 Fri -4d>= appear in red on the day.

 Also, with the =-4d=, this defines an interval [26 - 4, 26].

 If /today/ falls in the interval, the item will show in the current day in the
 agenda.  In that case it will be shown in orange.

**** Date commands                                                     :keys:
 | =C-c C-s=    | =org-schedule= | Add the =SCHEDULED:= keyword                            |
 | =C-s C-d=    | =org-deadline= | Add the =DEADLINE:= keyword                             |
 | =S-<arrows>= | =_=            | Selects the next/previous date in the calendar selector |

 I just set the lead time by writing it in manually after having done =C-c C-d=,
 using =S-<arrow>= or clicking on the date, press =RET= and go in and insert
 =-4d= manually.

*** Bulk actions in the agenda                                         :keys:
 | =m= | Mark entries for bulk actions |
 | =u= | Unmark entries                |
 | =U= | Unmark all entries            |
 | =*= | Mark all entries current view |
 | =B= | Do bulk actions               |
 In the bulk actions
 | =s=   | Schedule marked items                |
 | =d=   | Deadline marked itmes                |
 | =+,-= | Add,Remove tags to,from marked items |
 | =$=   | Search within marked items           |
 I use it to unschedule all the things I had scheduled for today that did not get
 done.

 Example: Unschedule all marked items: Mark items using =m=, then press =C-u= to
 make the following bulk scheduling action unschedule.  Press =B= for the bulk
 action menu and press =s= to select =[s]chd= scheduling options.  There will be
 no date to enter.  All marked entries will be unscheduled.

 This is useful for scheduling things to do the next day.  One should always
 unschedule all undone things at the end of the day and not schedule them for the
 next day.  Otherwise your schedule will stop being a schedule and become a
 single growing todo list.

*** Use org clocking functions                                       :keys:
| C-c C-x C-i | org-clock-in |
| C-c C-x C-o | org-clock-out |
*** Habits
Entries with =:style: habit= in its property drawer and with a scheduled date
containing a =.+4d= or =.+4d/7d= to specify repetition.

It will show up in the agenda with a little graph displaying how you are doing.
*** Tables
Pres =C-c C-c= on the cell that has the ~=taylor(...)~ thing.
|---------------+---+---+-------------------|
| Func          | n | x | Result            |
|---------------+---+---+-------------------|
| exp(x)        | 1 | x | =taylor($1,$3,$2) |
| exp(x)        | 2 | x |                   |
| exp(x)        | 3 | x |                   |
| x^2 + sqrt(x) | 1 | x |                   |
| x^2 + sqrt(x) | 2 | x |                   |
|---------------+---+---+-------------------|

A thing appears below the table, put your cursor on that and do =C-c C-c=.

Ref [[https://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html][Org as a spreadsheet system : An introduction]]
** Things to do in general
*** Evaluate lisp code =C-x C-e=                                       :keys:

** Terminal stuff
*** Alt key in terminal emulator settings                          :terminal:
 On macos but maybe also on linux, my terminal emulator does something with my
 alt key and I have to go into Iterm preferences and change it.

 If in the shell you do =M-x= and it doesn't work, look for settings in your
 terminal emulator for Alt key behavior.
*** Tab key and evil mode
 TAB: (setq evil-want-C-i-jump nil).  =C-i= and =TAB= are kind of the same thing
 in the shell.  In evil mode, you need to set this to Nil, otherwise, it will do
 something with =C-i= that will prevent the =TAB= key from working in orgmode files.
** MacOS stuff

*** Preventing a specific only on MacOS and only in terminal emacsclient
 https://debbugs.gnu.org/cgi/bugreport.cgi?bug=22993#22
 also Note the need to change Alt in terminal emulator profile settings
** TRAMP

use =C-x C-f= and write =/ssh:ppp4:=, after the second =':'=, give TRAMP time to
connect and when the connection is established, the helm popup will show the
files on the remote machine.

It helps if the remote machine skips loading the profile when TRAMP connects by
adding something like this at the start (Ref : [[https://www.emacswiki.org/emacs/TrampMode#h5o-9][Emacs Wiki : Tramp Mode]])
#+begin_src shell
# ~/.profile 
# Skip loading for applications like TRAMP
if [[ "$TERM" == "dumb" ]] ; then
  PS1='$ '
  return
fi
#+end_src


If your shell on the remote machine is zsh:
#+begin_src shell
if [[ "$TERM" == "dumb" ]] ; then
  unsetopt zle
  unsetopt prompt_cr
  unsetopt prompt_subst
  if whence -w precmd >/dev/null; then
      unfunction precmd
  fi
  if whence -w preexec >/dev/null; then
      unfunction preexec
  fi
  PS1='$ '
  return
fi
#+end_src


* New stuff
** System Crafters for auto-save files
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

From https://github.com/daviwil/emacs-from-scratch/blob/a57d99ba80276926a2b68521f9a9d23dc173a628/Emacs.org#keep-folders-clean
#+begin_src emacs-lisp
;; NOTE: If you want to move everything out of the ~/.emacs.d folder
;; reliably, set `user-emacs-directory` before loading no-littering!
;(setq user-emacs-directory "~/.cache/emacs")

(use-package no-littering :ensure t)

;; no-littering doesn't set this by default so we must place
;; auto save files in the same path as it uses for sessions
(setq auto-save-file-name-transforms
      `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+end_src

#+RESULTS:
| .* | /Users/pcarphin/.emacs.d/var/auto-save/ | t |

;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))


** UTF-8
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:
UTF-8 as default encoding from
[[http://ergoemacs.org/emacs/emacs_encoding_decoding_faq.html][emacs encoding
decoding FAQ]] on [[https://ergoemacs.org][ergoemacs.org]]
#+begin_src emacs-lisp
(set-language-environment "UTF-8")
#+end_src

In an export to Reveal.js, "àÀèÈéÉçÇûÛùÙ" should show up correctly when the
language environment is UTF-8.




** Initial frame position
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:


For non-server mode
#+begin_src emacs-lisp
(set-frame-position (selected-frame) 800 0)
#+end_src

#+begin_src emacs-lisp :tangle no
(custom-set-variables
 '(server-after-make-frame-hook
   '((lambda nil
       (set-frame-position
        (selected-frame)
        400 400)))))
#+end_src
#+begin_src emacs-lisp
(add-hook 'after-make-frame-functions
   (lambda (f) (set-frame-position f 400 10)))
#+end_src


#+begin_src emacs-lisp
(custom-set-variables
 '(default-frame-alist
    '((height . 55)
      (width . 100)
      (vertical-scroll-bars))))
#+end_src


** GO mode

#+begin_src emacs-lisp
(use-package go :ensure t)
#+end_src


** doom modeline
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
:config
(setq doom-modeline-font "all-the-icons")
(setq doom-modeline-height 8)
(setq doom-modeline-icon t)
(doom-modeline-mode 1))
#+end_src


** Monokai themes
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
#+begin_src emacs-lisp
(use-package monokai-pro-theme :ensure t :config (load-theme 'monokai-pro-classic))
#+end_src


** Aaron Bieber's modeline

How does he get this powerline: https://youtu.be/JWD1Fpdd4Pc?t=1299

I must have it!

** smart-mode-line (meh at best)
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package smart-mode-line :ensure t
  :config
  (setq sml/theme 'powerline)
  (sml/setup))
#+end_src


** powerline
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:



#+begin_src shell :results output
mkdir -p ~/.emacs.d/vendor
cd ~/.emacs.d/vendor
git clone https://github.com/jonathanchu/emacs-powerline.git
#+end_src
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/vendor/emacs-powerline")
(require 'powerline)
(setq powerline-arrow-shape 'arrow)   ;; give your mode-line curves
#+end_src






** Org Habits
:PROPERTIES:
:HEADER-ARGS: :tangle yes
:END:

I have to put this =add-to-list= at the end of the file it seems

*** Activate ?
This is the only necessary config to be able to use org habits.
#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit t)
#+end_src
We can also do =M-x customize RET= and search for =org-modules=.
*** Trying things out
Almost required otherwise habits can't be more than like 7 letters long.
#+begin_src emacs-lisp
(setq org-habit-graph-column 60)
#+end_src

*** Show habits on other days

Not sure if I like this, trying it for now.
#+begin_src 
(setq org-habit-show-habits-only-for-today nil)
#+end_src


** Org-id

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-id t)
#+end_src
