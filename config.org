#+OPTIONS: toc:1
#+REVEAL_MIN_SCALE: 0.1
#+REVEAL_HLEVEL: 4
#+PROPERTY: header-args :tangle yes

* Minimalistic config
** Intro
#+REVEAL: split
An elementary that can be taken as is to start from oriented towards leveragin
the full power of orgmode immediately.
- Sane miscellaneous defaults
- A built in color theme that looks good in orgmode exports
- Evil mode if you know vim but not emacs
- Basic helper frameworks that are defacto standard
- Elementary org configuration allowing immediate use of built in package babel.

*** This config file

Emacs loads one file at startup from =~/.emacs=, =~/.emacs.d/init.el=.  The s
** Package stuff

   Standard stuff that is at the start of everyone's config file.
#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org"   . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("gnu"   . "http://elpa.gnu.org/packages/") t)
(package-initialize)
#+end_src

Standard way for installing packages.  This replaces the use of =(require
a-package)= and adds convenience functions.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
(eval-when-compile (require 'use-package))
#+end_src

** Scrolling behavior

- =scroll-margin= Distance between cursor and top/bottom before scrolling starts.
- =scroll-step= makes the window move one line at a time.

#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq-default scroll-margin 10)
#+end_src

** Wrapping

Automattically hard-wrap text on 80 chars.

#+begin_src emacs-lisp
(setq-default auto-fill-function 'do-auto-fill)
(setq-default fill-column 80)
#+end_src

** Startup color theme

Dark theme that exports well

#+begin_src emacs-lisp
(load-theme 'misterioso)
#+end_src

**** Explanation                                                   :noexport_reveal:

    The default emacs theme looks good when exporting to HTML.  But because of
    =htmlize=, with dark themes, the code can come out looking bad in exports
    when text colors meant for dark backgrounds appear over the light background
    of the HTML.

    One of the built-in color themes where code looks good on light backgrounds
    and which is easy on the eyes is =misterioso=

    Although the default emacs theme exports well, it's not easy on the eyes in
    emacs itself.  A light theme that exports well and looks good in emacs is
    =leuven=.

** Startup font
   
To change the font, as per this [[http://emacs.1067599.n8.nabble.com/Changing-font-size-of-all-the-buffers-including-the-status-line-and-the-characters-shown-in-electricr-tp466906p466932.html][Mailing list post]].

#+begin_src emacs-lisp
(custom-set-faces '(default ((t (:height 200)))))
#+end_src

** Helper frameworks

*** Undo tree
    Use =C-x u= to get an undo tree buffer, really strong!
#+begin_src emacs-lisp
(use-package undo-tree
  :ensure t
  :config (global-undo-tree-mode))
#+end_src
*** Helm

Improve searching interface all over emacs.

Calling =helm-mode= remaps lots of emacs functions to their =helm=-ized
equivalents.

We also add a few ourselves.

#+begin_src emacs-lisp
(use-package helm :ensure t
  :preface (require 'helm-config)
  :config (helm-mode)
  :bind (("M-x" . helm-M-x)
	 ("C-x C-f" . helm-find-files)
	 ("C-x C-r" . helm-recentf)
	 ("C-x C-b" . helm-buffers-list)
	 ("C-c g" . helm-grep-do-git-grep)))
#+end_src

**** Remapped functions

     Notable remapped functions:
- =M-x= adds helm when writing function
- Files and buffers
  - =helm-recentf=
  - =helm-find-files=
  - =helm-buffer-list=
- =helm-mode=
  - =describe-function=
  - =describe-symbol=

**** Powerful tools

- =helm-grep-do-git-grep=

*** Which-key

Help discovering available key sequences in all contexts.

Originally developped for spacemacs, now part of the standard emacs packages.

#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :delight
  :init
  (setq which-key-separator " ")
  (setq which-key-prefix-prefix "+")
  (setq which-key-idle-delay 0.01)
  :config
  (which-key-mode))
#+end_src

*** Standard autocomplete

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :config (global-company-mode)
          (setq company-idle-delay 0))
#+end_src
** Org configuration
*** Looks
**** Bullets

Show nice bullets

Essential for easy tree viewing

#+begin_src emacs-lisp
(use-package org-bullets
  :ensure t
  :hook (org-mode . org-bullets-mode))
#+end_src

*** Exporting

- =ox-twbs= to export to beautiful HTML
- =ox-reveal= to export to Reveal.js presentation
- =ox-rst= to generate Restructured Text for sphinx documentation
- =htmlize= for colored code in all export formats

#+begin_src emacs-lisp
(use-package ox-rst :ensure t)
(use-package ox-twbs :ensure t)
(use-package ox-reveal :ensure t
  :config (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
(use-package htmlize :ensure t)
#+end_src

*** Babel
**** Babel Intro
Babel allows running of code blocks.  It is what enables this config to be in
orgmode format.

The ability to evaluate code in orgmode source blocks is built in with emacs but
must be activated to be used:

https://orgmode.org/worg/org-contrib/babel/languages/index.html#configure

**** Babel config
We simply add languages that we want to become available.  There are many more
but some of them require installing extra packages.

#+begin_src emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages
    '((shell . t)
      (python . t)))
#+end_src

**** Disable prompt
As a security precaution this is off by default.  It would indeed be quite
surprising if your text editor runs a shell command if you accidently do =C-c
C-c=.

But if you know it exists, then there is no big deal.  Indeed one is not
surprised that a command runs when the press enter in a shell.

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src
    
** Evil mode
   :PROPERTIES:
   :header-args: :tangle yes
   :END:
*** Install and activate

#+begin_src emacs-lisp :results none
  (use-package evil
    :ensure t
    :init (setq evil-want-C-i-jump nil)
	  (setq evil-want-integration t)
	  (setq evil-want-C-u-scroll t)
    :config (evil-mode 1)
            (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
            (evil-global-set-key 'motion "j" 'evil-next-visual-line)
            (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
            (setq evil-default-state 'emacs)
            (setq evil-insert-state-modes nil)
            (setq evil-motion-state-modes nil)
            (setq evil-normal-state-modes '(fundamental-mode
                                            conf-mode
                                            prog-mode
                                            text-mode
                                            dired))
            (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+end_src

The =evil-want-C-i-jump= is very important.  When running emacs in the shell,
the TAB key doesn't work properly.

Reference : [[https://www.youtube.com/watch?v=xaZMwNELaJY][Emacs From Scratch #3 : Keybindings and Evil]] et la config de Sam.

**** TODO Look into rune/evil-hook

*** Vim like window split keys

#+begin_src emacs-lisp
(define-key evil-insert-state-map (kbd "C-w") evil-window-map)
(define-key evil-insert-state-map (kbd "C-w /") 'split-window-right)
(define-key evil-insert-state-map (kbd "C-w -") 'split-window-below)
#+END_SRC

*** Map undo keys to undo-tree function

#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "C-r") 'undo-tree-redo)
(define-key evil-normal-state-map (kbd "u") 'undo-tree-undo)
#+end_src


* Advanced

** Orgmode implementation of GTD
*** Agenda files
   :PROPERTIES:
   :header-args: :tangle no
   :END:

 To begin using org-agenda, all we need to do is to give it a directory that
 contains orgmode files.

 #+begin_src emacs-lisp
 (setq org-agenda-dir "~/NDocuments/gtd")
 (setq org-agenda-files (list org-agenda-dir))
 #+end_src

I don't know why I can't use org-agenda-dir here but if I put org-agenda-dir
where the string litteral is, it doesn't work.

It gives the message

#+begin_src text
Wrong type argument : stringp, org-agenda-dir.
#+end_src

*** GTD
    
   #+REVEAL: split
**** Keymap for GTD keybindings
      We define a keymap that will be accessed with =SPC a g=
 #+begin_src emacs-lisp
   (define-prefix-command 'gtd)
   (define-key evil-normal-state-map (kbd "SPC a g") 'gtd)
   (define-key gtd (kbd "a") 'org-agenda)
 #+end_src

   #+REVEAL: split

**** GTD files
***** Filename symbols
#+begin_src emacs-lisp :results none
(setq org-agenda-dir "~/NDocuments/gtd/")
(setq org-agenda-files '("~/NDocuments/gtd"))
(setq gtd-in-tray-file (concat org-agenda-dir "GTD_InTray.org")
    gtd-next-actions-file (concat org-agenda-dir "GTD_NextActions.org")
    gtd-project-list-file (concat org-agenda-dir "GTD_ProjectList.org")
    gtd-reference-file (concat org-agenda-dir "GTD_Reference.org")
    gtd-someday-maybe-file (concat org-agenda-dir "GTD_SomedayMaybe.org")
    gtd-tickler-file (concat org-agenda-dir "GTD_Tickler.org")
    gtd-journal-file (concat org-agenda-dir "GTD_Journal.org"))
#+end_src
***** Quick access to GTD files

  We use it to create bindings in the =gtd= map to open files

  #+begin_src emacs-lisp
    (defun gtd-open-in-tray      () (interactive) (find-file gtd-in-tray-file))
    (defun gtd-open-project-list () (interactive) (find-file gtd-project-list-file))
    (defun gtd-open-reference   () (interactive) (find-file gtd-reference-file))
    (defun gtd-open-next-actions () (interactive) (find-file gtd-next-actions-file))
    (define-key gtd (kbd "i") 'gtd-open-in-tray)
    (define-key gtd (kbd "p") 'gtd-open-project-list)
    (define-key gtd (kbd "r") 'gtd-open-reference)
    (define-key gtd (kbd "n") 'gtd-open-next-actions)
  #+end_src

    #+REVEAL: split
**** Todo keywords for GTD

 The first set of keywords is a generic set of keywords that I can give TODO
 keywords to items without having them be part of my GTD.

 The GTD-* keywords map to the various things that what David Allen calls "stuff"
 can be.

 #+begin_src emacs-lisp
 (setq org-todo-keywords '((sequence "TODO" "WAITING" "VERIFY" "|" "DONE")
			   (sequence 
                              "GTD-IN(i)"
                              "GTD-CLARIFY(c)"
			      "GTD-PROJECT(p)"
                              "GTD-SOMEDAY-MAYBE(s)"
			      "GTD-ACTION(a)"
                              "GTD-NEXT-ACTION(n)"
                              "GTD-WAITING(w)"
			      "|"
                              "GTD-REFERENCE(r)"
                              "GTD-DELEGATED(g)"
			      "GTD-DONE(d)")))
			   
 (setq org-todo-keyword-faces
    '(("GTD-IN" :foreground "#ff8800" :weight normal :underline t :size small)
      ("GTD-PROJECT" :foreground "#0088ff" :weight bold :underline t)
      ("GTD-ACTION" :foreground "#0088ff" :weight normal :underline nil)
      ("GTD-NEXT-ACTION" :foreground "#0088ff" :weight bold :underline nil)
      ("GTD-WAITING" :foreground "#aaaa00" :weight normal :underline nil)
      ("GTD-REFERENCE" :foreground "#00ff00" :weight normal :underline nil)
      ("GTD-SOMEDAY-MAYBE" :foreground "#7c7c74" :weight normal :underline nil)
      ("GTD-DONE" :foreground "#00ff00" :weight normal :underline nil)))
 #+end_src

   #+REVEAL: split
**** Definition of stuck projects

 In GTD projects are called "stuck" if they do not contain a =GTD-NEXT-ACTION=.
 This says that a stuck project is a headline where the todo keyword is
 =GTD-PROJECT= that do not contain a heading matching =GTD-NEXT-ACTION=.

 #+begin_src emacs-lisp
 (setq org-stuck-projects
       '("TODO=\"GTD-PROJECT\"" ;; Search query
         ("GTD-NEXT-ACTION")    ;; Not stuck if contains
         ()                     ;; Stuck if contains
         ""))                   ;; General regex
 #+end_src

 
**** Capturing
***** Capture templates
 #+begin_src emacs-lisp
 (setq org-capture-templates 
   '(("i" "GTD Input" entry (file+headline gtd-in-tray-file "GTD Input Tray")
      "* GTD-IN %?\n %i\n %a" :kill-buffer t)))
 #+end_src
***** Capture hotkey
 #+begin_src emacs-lisp
   (global-set-key (kbd "C-c c") 'org-capture)
 #+end_src

 #+RESULTS:
 : org-capture

*** Org Agenda
   #+REVEAL: split
    
**** Intro
 The agenda has features for working with tags and todo keywords.

 It provides ways of

 - Searching
 - Bulk editing
 - Creating views

 based on

 - TODO keywords
 - Tags
 - Dates (using the =DEADLINE= and =SCHEDULED= properties)
  
 I have adapted my use of the agenda to GTD but the methods here can serve as
 general examples nonetheless.
   #+REVEAL: split
    
**** Date interval for agenda view

 The default is kind of annoying.  It shows a week starting on a Sunday but what
 is annoying about that is that on Sunday, the agenda won't show what you have
 tomorrow!

 The way this is set, it will show 10 days starting 3 days in the past.

 #+begin_src emacs-lisp :results none
 (setq org-agenda-span 7
       org-agenda-start-on-weekday 0
       org-agenda-start-day "-2d")
 #+end_src

   #+REVEAL: split
    
**** Agenda Key
 I mapped a key because I like to pop in and out of it.

 #+begin_src emacs-lisp
 (global-set-key (kbd "C-c a") 'org-agenda)
 #+end_src

   #+REVEAL: split
    
**** Agenda custom commands

 #+begin_src emacs-lisp
 (setq org-agenda-custom-commands
       '(("c" "Simple agenda view"
           ((tags "PRIORITY=\"A\"")
            (stuck "" )
            (agenda "")
            (todo "GTD-ACTION")))
         ("g" . "GTD keyword searches searches")
         ("gi" todo "GTD-IN")
         ("gc" todo "GTD-CLARIFY")
         ("ga" todo "GTD-ACTION")
         ("gn" todo-tree "GTD-NEXT-ACTION")
         ("gp" todo "GTD-PROJECT")))
 #+end_src

*** Closing notes
#+begin_src emacs-lisp :results none
(setq org-log-done 'note)
#+end_src
** Magit

The most amazing vim plugin in existence.

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src


* New

** Yasnippet
I thought this was going to give me the thing where doing =<sTAB= while in
insert mode would expand to org mode source blocks.

This [[https://emacs.stackexchange.com/questions/46988/why-do-easy-templates-e-g-s-tab-in-org-9-2-not-work/63561#63561][stack overflow post]] shows that org 9.2 simply changed it to =C-c C-,=.
Knowing that, I think it's for the best since it now works with visual
selections.

Since I looked into [[https://www.emacswiki.org/emacs/Yasnippet][yasnippet]] I might as well install it and start using it.

#+begin_src emacs-lisp :results none
(use-package yasnippet
  :ensure t
  :config (yas-global-mode 1))
#+end_src
